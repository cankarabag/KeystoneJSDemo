import { GraphQLSchema, KindEnum } from 'graphql';
import { ASTNode, DocumentNode, FragmentDefinitionNode, NamedTypeNode, TypeDefinitionNode } from 'graphql/language';
import { ValidationContext } from 'graphql/validation';
import { GraphQLArgument, GraphQLEnumValue, GraphQLField, GraphQLInputFieldMap, GraphQLType } from 'graphql/type/definition';
import { GraphQLDirective } from 'graphql/type/directives';
export { GraphQLConfig, GraphQLProjectConfig };
import { GraphQLConfig, GraphQLProjectConfig } from 'graphql-config';
export declare type TokenPattern = string | ((char: string) => boolean) | RegExp;
export interface CharacterStream {
    getStartOfToken: () => number;
    getCurrentPosition: () => number;
    eol: () => boolean;
    sol: () => boolean;
    peek: () => string | null;
    next: () => string;
    eat: (pattern: TokenPattern) => string | undefined;
    eatWhile: (match: TokenPattern) => boolean;
    eatSpace: () => boolean;
    skipToEnd: () => void;
    skipTo: (position: number) => void;
    match: (pattern: TokenPattern, consume?: boolean | null | undefined, caseFold?: boolean | null | undefined) => Array<string> | boolean;
    backUp: (num: number) => void;
    column: () => number;
    indentation: () => number;
    current: () => string;
}
export declare type GraphQLConfiguration = GraphQLProjectConfiguration & {
    projects?: {
        [projectName: string]: GraphQLProjectConfiguration;
    };
};
export declare type GraphQLProjectConfiguration = {
    name?: string;
    schemaPath?: string;
    includes?: Array<string>;
    excludes?: Array<string>;
    extensions?: GraphQLConfigurationExtension;
};
export declare type GraphQLConfigurationExtension = {
    [name: string]: unknown;
};
export interface GraphQLCache {
    getGraphQLConfig: () => GraphQLConfig;
    getObjectTypeDependencies: (query: string, fragmentDefinitions: Map<string, ObjectTypeInfo> | null | undefined) => Promise<Array<ObjectTypeInfo>>;
    getObjectTypeDependenciesForAST: (parsedQuery: ASTNode, fragmentDefinitions: Map<string, ObjectTypeInfo>) => Promise<Array<ObjectTypeInfo>>;
    getObjectTypeDefinitions: (graphQLConfig: GraphQLProjectConfig) => Promise<Map<string, ObjectTypeInfo>>;
    updateObjectTypeDefinition: (rootDir: Uri, filePath: Uri, contents: Array<CachedContent>) => Promise<undefined>;
    updateObjectTypeDefinitionCache: (rootDir: Uri, filePath: Uri, exists: boolean) => Promise<undefined>;
    getFragmentDependencies: (query: string, fragmentDefinitions: Map<string, FragmentInfo> | null | undefined) => Promise<Array<FragmentInfo>>;
    getFragmentDependenciesForAST: (parsedQuery: ASTNode, fragmentDefinitions: Map<string, FragmentInfo>) => Promise<Array<FragmentInfo>>;
    getFragmentDefinitions: (graphQLConfig: GraphQLProjectConfig) => Promise<Map<string, FragmentInfo>>;
    updateFragmentDefinition: (rootDir: Uri, filePath: Uri, contents: Array<CachedContent>) => Promise<undefined>;
    updateFragmentDefinitionCache: (rootDir: Uri, filePath: Uri, exists: boolean) => Promise<undefined>;
    getSchema: (appName: string | null | undefined, queryHasExtensions?: boolean | null | undefined) => Promise<GraphQLSchema | null | undefined>;
    handleWatchmanSubscribeEvent: (rootDir: string, projectConfig: GraphQLProjectConfig) => (result: Object) => undefined;
}
export interface Position {
    line: number;
    character: number;
    lessThanOrEqualTo: (position: Position) => boolean;
}
export interface Range {
    start: Position;
    end: Position;
    containsPosition: (position: Position) => boolean;
}
export declare type CachedContent = {
    query: string;
    range: Range | null | undefined;
};
export declare type RuleOrString = Rule | string;
export declare type ParseRule = RuleOrString[] | ((token: Token, stream: CharacterStream) => string | null | void);
export declare type Token = {
    kind: string;
    value: string;
};
export declare type Rule = {
    style?: string;
    match?: (token: Token) => boolean;
    update?: (state: State, token: Token) => void;
    separator?: string | Rule;
    isList?: boolean;
    ofRule?: Rule | string;
};
export declare type RuleKind = KindEnum | 'AliasedField' | 'Arguments' | 'ShortQuery' | 'Query' | 'Mutation' | 'Subscription' | 'TypeCondition' | 'Invalid' | 'Comment' | 'SchemaDef' | 'ScalarDef' | 'ObjectTypeDef' | 'InterfaceDef' | 'UnionDef' | 'EnumDef' | 'FieldDef' | 'InputDef' | 'InputValueDef' | 'ArgumentsDef' | 'ExtendDef' | 'DirectiveDef';
export declare type State = {
    level: number;
    levels?: Array<number>;
    prevState: State | null | undefined;
    rule: ParseRule | null | undefined;
    kind: RuleKind | null | undefined;
    name: string | null | undefined;
    type: string | null | undefined;
    step: number;
    needsSeperator: boolean;
    needsAdvance?: boolean;
    indentLevel?: number;
};
export declare type Uri = string;
export declare type GraphQLFileMetadata = {
    filePath: Uri;
    size: number;
    mtime: number;
};
export declare type GraphQLFileInfo = {
    filePath: Uri;
    content: string;
    asts: Array<DocumentNode>;
    size: number;
    mtime: number;
};
export declare type ContextToken = {
    start: number;
    end: number;
    string: string;
    state: State;
    style: string;
};
export declare type AllTypeInfo = {
    type: GraphQLType | null | undefined;
    parentType: GraphQLType | null | undefined;
    inputType: GraphQLType | null | undefined;
    directiveDef: GraphQLDirective | null | undefined;
    fieldDef: GraphQLField<any, any> | null | undefined;
    enumValue: GraphQLEnumValue | null | undefined;
    argDef: GraphQLArgument | null | undefined;
    argDefs: Array<GraphQLArgument> | null | undefined;
    objectFieldDefs: GraphQLInputFieldMap | null | undefined;
};
export declare type FragmentInfo = {
    filePath?: Uri;
    content: string;
    definition: FragmentDefinitionNode;
};
export declare type NamedTypeInfo = {
    filePath?: Uri;
    content: string;
    definition: NamedTypeNode;
};
export declare type ObjectTypeInfo = {
    filePath?: Uri;
    content: string;
    definition: TypeDefinitionNode;
};
export declare type CustomValidationRule = (context: ValidationContext) => Record<string, any>;
export declare type Diagnostic = {
    range: Range;
    severity?: number;
    code?: number | string;
    source?: string;
    message: string;
};
export declare type CompletionItem = {
    label: string;
    kind?: number;
    detail?: string;
    sortText?: string;
    documentation?: string | null | undefined;
    isDeprecated?: boolean | null | undefined;
    deprecationReason?: string | null | undefined;
};
export declare type Definition = {
    path: Uri;
    position: Position;
    range?: Range;
    id?: string;
    name?: string;
    language: string;
    projectRoot?: Uri;
};
export declare type DefinitionQueryResult = {
    queryRange: Array<Range>;
    definitions: Array<Definition>;
};
export declare type TokenKind = 'keyword' | 'class-name' | 'constructor' | 'method' | 'param' | 'string' | 'whitespace' | 'plain' | 'type';
export declare type TextToken = {
    kind: TokenKind;
    value: string | undefined;
};
export declare type TokenizedText = Array<TextToken>;
export declare type OutlineTree = {
    plainText?: string;
    tokenizedText?: TokenizedText;
    representativeName?: string;
    startPosition: Position;
    endPosition?: Position;
    children: Array<OutlineTree>;
};
export declare type Outline = {
    outlineTrees: Array<OutlineTree>;
};
export interface DidChangeWatchedFilesParams {
    changes: FileEvent[];
}
export interface FileEvent {
    uri: string;
    type: FileChangeType;
}
export declare const FileChangeTypeKind: {
    Created: number;
    Changed: number;
    Deleted: number;
};
export declare type FileChangeTypeKind = {
    Created: 1;
    Changed: 2;
    Deleted: 3;
};
export declare type FileChangeTypeKeys = keyof FileChangeTypeKind;
export declare type FileChangeType = FileChangeTypeKind[FileChangeTypeKeys];
//# sourceMappingURL=index.d.ts.map