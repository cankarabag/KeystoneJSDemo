"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), core = require("@emotion/core"), react = require("react"), reactDom = require("react-dom"), flushable = _interopDefault(require("flushable")), styled = _interopDefault(require("@emotion/styled")), reactPopper = require("react-popper"), modalUtils = require("@arch-ui/modal-utils"), theme = require("@arch-ui/theme");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const TooltipElement = styled.div({
  backgroundColor: theme.colors.N80,
  borderRadius: 3,
  color: "white",
  fontSize: "0.75rem",
  fontWeight: 500,
  padding: "".concat(theme.gridSize / 2, "px ").concat(theme.gridSize, "px"),
  pointerEvents: "none",
  zIndex: 2
});

let TooltipPositioner = props => reactDom.createPortal(core.jsx(reactPopper.Popper, {
  referenceElement: props.targetNode,
  placement: props.placement,
  modifiers: {
    hide: {
      enabled: !1
    },
    preventOverflow: {
      enabled: !1
    }
  }
}, _ref => {
  let {ref: ref, style: style} = _ref;
  return core.jsx("div", {
    ref: ref,
    css: {
      zIndex: 2e3
    },
    style: _objectSpread({}, props.style, {}, style)
  }, core.jsx("div", {
    css: {
      margin: theme.gridSize
    }
  }, core.jsx(TooltipElement, {
    className: props.className
  }, props.children)));
}), document.body);

const LISTENER_OPTIONS = {
  passive: !0
}, NOOP = () => {};

let pendingHide;

const showTooltip = (fn, defaultDelay) => {
  const isHidePending = pendingHide && pendingHide.pending();
  return isHidePending && pendingHide.flush(), flushable(() => fn(isHidePending), isHidePending ? 0 : defaultDelay).cancel;
}, hideTooltip = (fn, defaultDelay) => (pendingHide = flushable(flushed => fn(flushed), defaultDelay)).cancel;

class Tooltip extends react.Component {
  constructor() {
    super(...arguments), _defineProperty(this, "state", {
      immediatelyHide: !1,
      immediatelyShow: !1,
      isVisible: !1
    }), _defineProperty(this, "ref", react.createRef()), _defineProperty(this, "cancelPendingSetState", NOOP), 
    _defineProperty(this, "cancel", () => {
      this.cancelPendingSetState(), this.setState({
        isVisible: !1,
        immediatelyHide: !0
      });
    }), _defineProperty(this, "handleMouseEnter", () => {
      this.cancelPendingSetState(), this.state.isVisible || (this.props.hideOnMouseDown && this.ref.current && this.ref.current.addEventListener("mousedown", this.cancel, LISTENER_OPTIONS), 
      this.props.hideOnKeyDown && document.addEventListener("keydown", this.cancel, LISTENER_OPTIONS), 
      this.cancelPendingSetState = showTooltip(immediatelyShow => {
        this.setState({
          isVisible: !0,
          immediatelyShow: immediatelyShow
        });
      }, this.props.delay));
    }), _defineProperty(this, "handleMouseLeave", () => {
      this.cancelPendingSetState(), this.state.isVisible && (this.props.hideOnMouseDown && this.ref.current && this.ref.current.removeEventListener("mousedown", this.cancel, LISTENER_OPTIONS), 
      this.props.hideOnKeyDown && document.removeEventListener("keydown", this.cancel, LISTENER_OPTIONS), 
      this.cancelPendingSetState = hideTooltip(immediatelyHide => {
        this.setState({
          isVisible: !1,
          immediatelyHide: immediatelyHide
        });
      }, this.props.delay));
    });
  }
  componentDidMount() {
    const target = this.ref.current;
    if (!target) throw new Error("You must pass the ref onto your target node.");
    if (!target.nodeName) throw new Error("It looks like you've passed the ref onto a component. You must pass the ref onto your target node.");
    target.addEventListener("mouseenter", this.handleMouseEnter, LISTENER_OPTIONS), 
    target.addEventListener("mouseleave", this.handleMouseLeave, LISTENER_OPTIONS);
  }
  componentWillUnmount() {
    this.cancelPendingSetState();
    const target = this.ref.current;
    target && (target.removeEventListener("mouseenter", this.handleMouseEnter, LISTENER_OPTIONS), 
    target.removeEventListener("mouseleave", this.handleMouseLeave, LISTENER_OPTIONS));
  }
  render() {
    const {children: children, content: content, onHide: onHide, onShow: onShow, placement: placement, className: className} = this.props, {isVisible: isVisible} = this.state, ref = this.ref;
    return core.jsx(react.Fragment, null, children(ref), core.jsx(modalUtils.TransitionProvider, {
      isOpen: isVisible,
      onEntered: onShow,
      onExited: onHide
    }, transitionState => core.jsx(TooltipPositioner, {
      targetNode: this.ref.current,
      placement: placement,
      className: className,
      style: modalUtils.fade(transitionState)
    }, content)));
  }
}

_defineProperty(Tooltip, "defaultProps", {
  delay: 300,
  placement: "bottom"
}), exports.default = Tooltip;
