import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { jsx } from '@emotion/core';
import { Component, createRef, Fragment } from 'react';
import { createPortal } from 'react-dom';
import flushable from 'flushable';
import styled from '@emotion/styled';
import { Popper } from 'react-popper';
import { TransitionProvider, fade } from '@arch-ui/modal-utils';
import { colors, gridSize } from '@arch-ui/theme';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// Styled Component
// ==============================

const TooltipElement = styled.div({
  backgroundColor: colors.N80,
  borderRadius: 3,
  color: 'white',
  fontSize: '0.75rem',
  fontWeight: 500,
  padding: "".concat(gridSize / 2, "px ").concat(gridSize, "px"),
  pointerEvents: 'none',
  // tooltips are non-interactive, they shouldn't get in the way of other elements
  zIndex: 2
});

let TooltipPositioner = props => {
  return createPortal(jsx(Popper, {
    referenceElement: props.targetNode,
    placement: props.placement,
    modifiers: {
      hide: {
        enabled: false
      },
      preventOverflow: {
        enabled: false
      }
    }
  }, (_ref) => {
    let {
      ref,
      style
    } = _ref;
    return jsx("div", {
      ref: ref,
      css: {
        zIndex: 2000
      },
      style: _objectSpread({}, props.style, {}, style)
    }, jsx("div", {
      css: {
        margin: gridSize
      }
    }, jsx(TooltipElement, {
      className: props.className
    }, props.children)));
  }), document.body);
}; // ==============================
// Stateful Component
// ==============================


const LISTENER_OPTIONS = {
  passive: true
};

const NOOP = () => {};

let pendingHide;

const showTooltip = (fn, defaultDelay) => {
  const isHidePending = pendingHide && pendingHide.pending();

  if (isHidePending) {
    pendingHide.flush();
  }

  const pendingShow = flushable(() => fn(isHidePending), isHidePending ? 0 : defaultDelay);
  return pendingShow.cancel;
};

const hideTooltip = (fn, defaultDelay) => {
  pendingHide = flushable(flushed => fn(flushed), defaultDelay);
  return pendingHide.cancel;
};

class Tooltip extends Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      immediatelyHide: false,
      immediatelyShow: false,
      isVisible: false
    });

    _defineProperty(this, "ref", createRef());

    _defineProperty(this, "cancelPendingSetState", NOOP);

    _defineProperty(this, "cancel", () => {
      this.cancelPendingSetState();
      this.setState({
        isVisible: false,
        immediatelyHide: true
      });
    });

    _defineProperty(this, "handleMouseEnter", () => {
      this.cancelPendingSetState();

      if (this.state.isVisible) {
        return;
      }

      if (this.props.hideOnMouseDown && this.ref.current) {
        this.ref.current.addEventListener('mousedown', this.cancel, LISTENER_OPTIONS);
      }

      if (this.props.hideOnKeyDown) {
        document.addEventListener('keydown', this.cancel, LISTENER_OPTIONS);
      }

      this.cancelPendingSetState = showTooltip(immediatelyShow => {
        this.setState({
          isVisible: true,
          immediatelyShow
        });
      }, this.props.delay);
    });

    _defineProperty(this, "handleMouseLeave", () => {
      this.cancelPendingSetState();

      if (!this.state.isVisible) {
        return;
      }

      if (this.props.hideOnMouseDown && this.ref.current) {
        this.ref.current.removeEventListener('mousedown', this.cancel, LISTENER_OPTIONS);
      }

      if (this.props.hideOnKeyDown) {
        document.removeEventListener('keydown', this.cancel, LISTENER_OPTIONS);
      }

      this.cancelPendingSetState = hideTooltip(immediatelyHide => {
        this.setState({
          isVisible: false,
          immediatelyHide
        });
      }, this.props.delay);
    });
  }

  componentDidMount() {
    const target = this.ref.current;

    if (!target) {
      throw new Error('You must pass the ref onto your target node.');
    }

    if (!target.nodeName) {
      throw new Error("It looks like you've passed the ref onto a component. You must pass the ref onto your target node.");
    }

    target.addEventListener('mouseenter', this.handleMouseEnter, LISTENER_OPTIONS);
    target.addEventListener('mouseleave', this.handleMouseLeave, LISTENER_OPTIONS);
  }

  componentWillUnmount() {
    this.cancelPendingSetState();
    const target = this.ref.current;

    if (target) {
      target.removeEventListener('mouseenter', this.handleMouseEnter, LISTENER_OPTIONS);
      target.removeEventListener('mouseleave', this.handleMouseLeave, LISTENER_OPTIONS);
    }
  }

  render() {
    const {
      children,
      content,
      onHide,
      onShow,
      placement,
      className
    } = this.props;
    const {
      isVisible
    } = this.state;
    const ref = this.ref;
    return jsx(Fragment, null, children(ref), jsx(TransitionProvider, {
      isOpen: isVisible,
      onEntered: onShow,
      onExited: onHide
    }, transitionState => jsx(TooltipPositioner, {
      targetNode: this.ref.current,
      placement: placement,
      className: className,
      style: fade(transitionState)
    }, content)));
  }

}

_defineProperty(Tooltip, "defaultProps", {
  delay: 300,
  placement: 'bottom'
});

export default Tooltip;
