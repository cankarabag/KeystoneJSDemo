'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var core = require('@emotion/core');
var styled = _interopDefault(require('@emotion/styled'));
var dateFns = require('date-fns');
var reactWindow = require('react-window');
var icons = require('@arch-ui/icons');
var React = require('react');
var theme = require('@arch-ui/theme');
var typography = require('@arch-ui/typography');
require('intersection-observer');
var input = require('@arch-ui/input');
var Select = _interopDefault(require('@arch-ui/select'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/objectWithoutProperties'));
var chrono = _interopDefault(require('chrono-node'));
var moment = _interopDefault(require('moment'));

const yearRange = (from, to) => {
  const years = [];
  let year = from;

  while (year <= to) {
    years.push(year++);
  }

  return years;
};
const months = Array.from({
  length: 12
}, (_, i) => i); // https://github.com/geeofree/kalendaryo/blob/master/src/index.js#L245-L279

function createDayObject(dateValue) {
  return {
    dateValue,
    label: dateFns.getDate(dateValue)
  };
}

function getWeeksInMonth(date) {
  const weekOptions = {
    weekStartsOn: 0
  };
  const firstDayOfMonth = dateFns.startOfMonth(date);
  const firstDayOfFirstWeek = dateFns.startOfWeek(firstDayOfMonth, weekOptions);
  const lastDayOfFirstWeek = dateFns.endOfWeek(firstDayOfMonth, weekOptions);

  const getWeeks = (startDay, endDay, weekArray) => {
    const week = dateFns.eachDay(startDay, endDay).map(createDayObject);
    const weeks = [...weekArray, week];
    const nextWeek = dateFns.addWeeks(startDay, 1);
    const firstDayNextWeek = dateFns.startOfWeek(nextWeek, weekOptions);
    const lastDayNextWeek = dateFns.endOfWeek(nextWeek, weekOptions);

    if (dateFns.isSameMonth(firstDayNextWeek, date)) {
      return getWeeks(firstDayNextWeek, lastDayNextWeek, weeks);
    }

    return weeks;
  };

  return getWeeks(firstDayOfFirstWeek, lastDayOfFirstWeek, []);
}
function isNumberInRange(num, start, end) {
  return num >= start && num <= end;
}
function usePrevious(value) {
  const ref = React.useRef(value);
  React.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

/** @jsx jsx */
const monthOptions = months.map((month, i) => core.jsx("option", {
  key: i,
  value: i
}, dateFns.format(dateFns.setMonth(new Date(), month), 'MMM')));
const SelectMonth = React.memo((_ref) => {
  let {
    onChange: _onChange,
    month
  } = _ref;
  return core.jsx("select", {
    id: "ks-select-month",
    onChange: event => {
      _onChange(Number(event.target.value));
    },
    value: month
  }, monthOptions);
});
const SelectYear = React.memo((_ref2) => {
  let {
    onChange,
    year,
    yearRangeFrom,
    yearRangeTo,
    yearPickerType
  } = _ref2;
  const years = yearRange(yearRangeFrom, yearRangeTo); // using internal state so that the user can input invalid values
  // but the parent component will only recieve valid values

  const [internalValue, setInternalValue] = React.useState(year);
  const previousYearProp = usePrevious(year);
  React.useEffect(() => {
    if (previousYearProp !== year) {
      setInternalValue(year);
    }
  }, [previousYearProp, year, setInternalValue]);

  const handleChange = event => {
    const value = Number(event.target.value);
    setInternalValue(value);

    if (isNumberInRange(value, yearRangeFrom, yearRangeTo)) {
      onChange(value);
    }
  };

  if (years.length > 50 && yearPickerType === 'auto' || yearPickerType === 'input') {
    return core.jsx("input", {
      id: "ks-input-year",
      type: "number",
      min: yearRangeFrom,
      max: yearRangeTo,
      onChange: handleChange,
      value: internalValue
    });
  } else {
    return core.jsx("select", {
      id: "ks-select-year",
      onChange: handleChange,
      value: internalValue
    }, years.map((yearOption, i) => core.jsx("option", {
      key: i,
      value: yearOption
    }, yearOption)));
  }
});

const WeekRow = styled.div({
  display: 'flex'
});
const WeekLabels = styled(WeekRow)({
  color: theme.colors.N40,
  fontSize: '0.65rem',
  fontWeight: 500,
  textTransform: 'uppercase'
});
const Day = styled.div((_ref) => {
  let {
    disabled,
    isInteractive,
    isSelected,
    isToday
  } = _ref;
  let textColor;
  if (isToday) textColor = theme.colors.danger;
  if (disabled) textColor = theme.colors.N40;
  if (isSelected) textColor = 'white';
  return {
    alignItems: 'center',
    backgroundColor: isSelected ? theme.colors.primary : null,
    borderRadius: theme.borderRadius,
    color: textColor,
    cursor: isInteractive ? 'pointer' : 'default',
    display: 'flex',
    flexDirection: 'column',
    fontWeight: isSelected || isToday ? 'bold' : null,
    flexBasis: 'calc(100% / 7)',
    padding: '0.5rem',
    textAlign: 'center',
    width: 'calc(100% / 7)',
    ':hover': {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L90 : null,
      color: isInteractive && !isSelected && !isToday ? theme.colors.B.D40 : null
    },
    ':active': {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L80 : null
    }
  };
});

/** @jsx jsx */
const TodayMarker = styled.div((_ref) => {
  let {
    isSelected
  } = _ref;
  return {
    backgroundColor: isSelected ? 'white' : theme.colors.danger,
    borderRadius: 4,
    height: 2,
    marginBottom: -4,
    marginTop: 2,
    width: '1em'
  };
});
const Month = React.memo((_ref2) => {
  let {
    style,
    index,
    data
  } = _ref2;
  const {
    items,
    selectedDate,
    onSelectedChange,
    observer
  } = data;
  const ref = React.useRef(null);
  React.useEffect(() => {
    const node = ref.current;

    if (node !== null) {
      observer.observe(node);
      return () => observer.unobserve(node);
    }
  }, [observer]);
  const {
    weeks,
    month,
    year
  } = items[index];
  return core.jsx("div", {
    ref: ref,
    "data-index": index,
    id: "ks-month-".concat(month, "-").concat(year),
    style: style
  }, core.jsx(MonthHeader, {
    month: month,
    year: year
  }), weeks.map((week, i) => core.jsx(WeekRow, {
    key: i
  }, week.map(day => {
    const date = new Date(year, month, 3);
    const disabled = !dateFns.isSameMonth(date, day.dateValue);
    const isSelected = !disabled && selectedDate !== null && dateFns.isEqual(selectedDate, day.dateValue);
    const isToday = dateFns.isToday(day.dateValue);
    return core.jsx(Day, {
      id: "ks-day-".concat(day.label, "-").concat(month, "-").concat(year),
      key: day.label,
      disabled: disabled,
      onClick: disabled ? null : () => onSelectedChange(day.dateValue),
      isInteractive: !disabled,
      isSelected: isSelected,
      isToday: isToday
    }, day.label, isToday ? core.jsx(TodayMarker, {
      isSelected: isSelected
    }) : null);
  }))));
});
let readableMonths = months.map(month => dateFns.format(dateFns.setMonth(new Date(), month), 'MMMM'));
const MonthHeader = React.memo((_ref3) => {
  let {
    month,
    year
  } = _ref3;
  return core.jsx("div", {
    css: {
      position: 'sticky',
      top: 0,
      width: '100%',
      backgroundColor: '#fff'
    }
  }, core.jsx("div", {
    css: {
      paddingTop: 4,
      paddingBottom: 4,
      border: "1px ".concat(theme.colors.N60, " solid"),
      borderLeft: 0,
      borderRight: 0,
      display: 'flex',
      justifyContent: 'space-between',
      paddingRight: 12
    }
  }, core.jsx("span", {
    css: {
      color: theme.colors.N60
    }
  }, readableMonths[month]), core.jsx("span", {
    css: {
      color: theme.colors.N60
    }
  }, year)));
});

const Wrapper = styled.div({
  fontSize: '0.85rem'
});
const Header = styled.div({
  alignItems: 'center',
  display: 'flex',
  justifyContent: 'space-between'
});

const HeaderButton = props => core.jsx("button", _extends({
  type: "button",
  css: {
    background: 'none',
    borderRadius: theme.borderRadius,
    border: 'none',
    cursor: 'pointer',
    padding: '0.5rem 0.75rem',
    outline: 'none',
    ':hover': {
      backgroundColor: theme.colors.N05
    },
    ':active': {
      backgroundColor: theme.colors.N10
    }
  }
}, props));

let DAY_HEIGHT = 32.5;

function scrollToDate(date, yearRangeFrom, yearRangeTo, list) {
  if (list !== null) {
    const year = dateFns.getYear(date);
    const month = date.getMonth(); // calculate the index instead of using find because this is much cheaper

    const index = (year - yearRangeFrom) * 12 + month;
    list.scrollToItem(index, 'start');
  }
}

let weekLabels = core.jsx(WeekLabels, null, [...new Array(7)].map((_, day) => dateFns.format(dateFns.setDay(new Date(), day), 'ddd')).map(d => core.jsx(Day, {
  key: d
}, d))); // this component will rerender a lot really quickly
// so there's lots of memoization

const DayPicker = (_ref) => {
  let {
    yearRangeFrom,
    yearRangeTo,
    yearPickerType,
    startCurrentDateAt,
    selectedDate,
    onSelectedChange
  } = _ref;
  const listRef = React.useRef(null);

  if (!isNumberInRange(startCurrentDateAt.getFullYear(), yearRangeFrom, yearRangeTo)) {
    // if startCurrentDateAt is out of the year range then we go to end of
    // the year of yearRangeTo, ideally we'd throw an error for this case
    // and fix all the incorrect values for startCurrentDateAt but that
    // would require a bunch of other changes so it just isn't worth it right now
    // since we're planning to change a lot of this stuff anyway
    let date = new Date();
    date.setFullYear(yearRangeTo);
    startCurrentDateAt = dateFns.endOfYear(date);
  }

  const [date, setDate] = React.useState(startCurrentDateAt);
  const shouldChangeScrollPositionRef = React.useRef(true);
  const controlledSetDate = React.useCallback(newDate => {
    shouldChangeScrollPositionRef.current = true;
    setDate(newDate);
  }, [shouldChangeScrollPositionRef, setDate]);
  React.useLayoutEffect(() => {
    if (shouldChangeScrollPositionRef.current) {
      scrollToDate(date, yearRangeFrom, yearRangeTo, listRef.current);
      shouldChangeScrollPositionRef.current = false;
    }
  }, [date, yearRangeFrom, yearRangeTo, listRef]);
  const years = React.useMemo(() => {
    return yearRange(yearRangeFrom, yearRangeTo);
  }, [yearRangeFrom, yearRangeTo]);
  const items = React.useMemo(() => {
    const _items = [];
    years.forEach(year => {
      months.forEach(month => {
        _items.push({
          year,
          month,
          weeks: getWeeksInMonth(new Date(year, month, 1))
        });
      });
    });
    return _items;
  }, [years]);
  const currentIndex = (date.getFullYear() - yearRangeFrom) * 12 + date.getMonth();
  const canGoNextMonth = currentIndex < items.length - 1;
  const canGoPreviousMonth = currentIndex > 0;
  const observer = React.useMemo(() => {
    return new IntersectionObserver(entries => {
      const filteredEntries = entries.filter(value => value.isIntersecting).sort((a, b) => {
        if (a.intersectionRatio > b.intersectionRatio) {
          return -1;
        }

        return 1;
      });

      if (filteredEntries.length !== 0) {
        let index = Number(filteredEntries[0].target.getAttribute('data-index'));
        let item = items[index];
        setDate(new Date(item.year, item.month, 1));
      }
    }, {
      threshold: 0.6
    });
  }, [items]);
  return core.jsx(Wrapper, null, core.jsx(Header, null, React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoPreviousMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.subMonths(currentDate, 1));
    }
  }, core.jsx(icons.ChevronLeftIcon, null), core.jsx(typography.A11yText, null, "Previous Month")), [controlledSetDate, canGoPreviousMonth]), core.jsx(SelectMonth, {
    onChange: React.useCallback(month => {
      controlledSetDate(currentDate => {
        return dateFns.setMonth(currentDate, month);
      });
    }, [controlledSetDate]),
    month: date.getMonth()
  }), core.jsx(SelectYear, {
    year: dateFns.getYear(date),
    onChange: React.useCallback(year => {
      controlledSetDate(currentDate => {
        return dateFns.setYear(currentDate, year);
      });
    }, [controlledSetDate]),
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType
  }), React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoNextMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.addMonths(currentDate, 1));
    }
  }, core.jsx(icons.ChevronRightIcon, null), core.jsx(typography.A11yText, null, "Next Month")), [controlledSetDate, canGoNextMonth])), core.jsx("div", null, weekLabels, core.jsx(reactWindow.VariableSizeList, {
    ref: listRef,
    itemSize: React.useCallback(index => {
      const {
        weeks
      } = items[index];
      return weeks.length * DAY_HEIGHT + 26.5;
    }, [items]),
    itemData: React.useMemo(() => ({
      items,
      selectedDate,
      onSelectedChange,
      observer
    }), [items, selectedDate, onSelectedChange, observer]),
    height: 6 * DAY_HEIGHT + 26.5,
    itemCount: years.length * 12,
    width: "100%"
  }, Month)));
};
DayPicker.defaultProps = {
  yearRangeFrom: dateFns.getYear(new Date()) - 100,
  yearRangeTo: dateFns.getYear(new Date()),
  yearPickerType: 'auto'
};

const options = ['-12', '-11', '-10', '-09', '-08', '-07', '-06', '-05', '-04', '-03', '-02', '-01', '+00', '+01', '+02', '+03', '+04', '+05', '+06', '+07', '+08', '+09', '+10', '+11', '+12', '+13', '+14'].map(o => ({
  value: "".concat(o, ":00"),
  label: "".concat(o, ":00")
}));
const DayTimePicker = props => {
  const {
    date,
    time,
    offset,
    htmlID,
    autoFocus,
    isDisabled
  } = props;
  const {
    handleDayChange,
    handleTimeChange,
    handleOffsetChange,
    yearRangeFrom,
    yearRangeTo,
    yearPickerType
  } = props;
  const TODAY = new Date();
  return React.createElement("div", {
    id: htmlID
  }, React.createElement(DayPicker, {
    autoFocus: autoFocus,
    onSelectedChange: handleDayChange,
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType,
    startCurrentDateAt: date ? dateFns.parse(date) : TODAY,
    selectedDate: date ? dateFns.parse(date) : null
  }), React.createElement(input.Input, {
    type: "time",
    name: "time-picker",
    value: time,
    onChange: handleTimeChange,
    disabled: isDisabled || false,
    id: "".concat(htmlID, "-time")
  }), React.createElement(Select, {
    value: options.find(option => option.value === offset),
    options: options,
    onChange: (_ref) => {
      let {
        value
      } = _ref;
      handleOffsetChange(value);
    },
    id: "".concat(htmlID, "-offset")
  }));
};

const TextDayPicker = (_ref) => {
  let {
    date,
    onChange,
    format: dateDisplayFormat = 'Do MMMM YYYY'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["date", "onChange", "format"]);

  const formatDate = newDate => {
    return newDate === null ? '' : dateFns.format(newDate, dateDisplayFormat);
  };

  const [value, setValue] = React.useState(formatDate(date));
  return core.jsx(input.Input, _extends({
    value: value,
    placeholder: "Enter a date...",
    onBlur: () => {
      const newDate = parseDate(value);
      onChange(newDate);
      setValue(formatDate(newDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function parseDate(value) {
  const parsed = chrono.parseDate(value);

  if (parsed === undefined) {
    return null;
  }

  return dateFns.format(parsed, 'YYYY-MM-DD');
}

let TextDayTimePicker = (_ref) => {
  let {
    date,
    onChange
  } = _ref,
      props = _objectWithoutProperties(_ref, ["date", "onChange"]);

  let [value, setValue] = React.useState('');
  let ref = React.useRef(null);
  React.useEffect(() => {
    setValue(formatDateTime(date));
  }, [date]);
  return core.jsx(input.Input, _extends({
    value: value,
    ref: ref,
    placeholder: "Enter a date and time...",
    onBlur: () => {
      let parsedDate = parseDate$1(value);
      onChange(parsedDate);
      setValue(formatDateTime(parsedDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function formatDateTime(date) {
  // why are we using moment when it's so large and provides a mutable API?
  // because chrono uses it and consistency is nice and
  // will probably make bugs with conversion less likely
  return date ? moment.parseZone(date).format('h:mm A Do MMMM YYYY Z') : '';
}

function parseDate$1(value) {
  let [parsedDate] = chrono.parse(value);

  if (parsedDate === undefined) {
    return null;
  }

  let dateMoment = parsedDateToMoment(parsedDate);
  return dateMoment.toISOString( // passing true here keeps the offset in the iso string rather than
  // convert it to UTC which is the default to align with native JS Dates
  true);
}

function parsedDateToMoment(parsedDate) {
  // a copy of https://github.com/wanasit/chrono/blob/fe8db4e5e5f9b44215f96958c811f806458013e9/src/result.js#L102-L122
  // with one change, rather than adjusting the time to the timezone offset, we store the offset
  let dateMoment = moment();
  let currentTimezoneOffset = moment().utcOffset();
  let {
    start
  } = parsedDate;
  dateMoment.set('year', start.get('year'));
  dateMoment.set('month', start.get('month') - 1);
  dateMoment.set('date', start.get('day'));
  dateMoment.set('hour', start.get('hour'));
  dateMoment.set('minute', start.get('minute'));
  dateMoment.set('second', start.get('second'));
  dateMoment.set('millisecond', start.get('millisecond'));
  let targetTimezoneOffset = start.get('timezoneOffset') !== undefined ? start.get('timezoneOffset') : currentTimezoneOffset;
  dateMoment.utcOffset(targetTimezoneOffset, // passing true keeps the local time the same but changes the universal time
  // this is what we want because we're setting the local time above
  true);
  return dateMoment;
}

exports.DayPicker = DayPicker;
exports.DayTimePicker = DayTimePicker;
exports.TextDayPicker = TextDayPicker;
exports.TextDayTimePicker = TextDayTimePicker;
