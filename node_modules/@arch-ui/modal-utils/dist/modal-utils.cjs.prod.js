"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), React = require("react"), React__default = _interopDefault(React), reactTransitionGroup = require("react-transition-group"), core = require("@emotion/core"), theme = require("@arch-ui/theme"), colorUtils = require("@arch-ui/color-utils"), ScrollLock = _interopDefault(require("react-scrolllock"));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const transitionDurationMs = 220, transitionDuration = "".concat(220, "ms"), transitionTimingFunction = "cubic-bezier(0.2, 0, 0, 1)", TransitionProvider = _ref => {
  let {children: children, isOpen: isOpen} = _ref, props = _objectWithoutProperties(_ref, [ "children", "isOpen" ]);
  return React__default.createElement(reactTransitionGroup.TransitionGroup, {
    component: null
  }, isOpen ? React__default.createElement(reactTransitionGroup.Transition, _extends({
    appear: !0,
    mountOnEnter: !0,
    unmountOnExit: !0,
    timeout: 220
  }, props), state => children(state)) : null);
}, withTransitionState = Comp => _ref2 => {
  let {isOpen: isOpen} = _ref2, props = _objectWithoutProperties(_ref2, [ "isOpen" ]);
  return React__default.createElement(TransitionProvider, {
    isOpen: Boolean(isOpen)
  }, state => React__default.createElement(Comp, _extends({
    transitionState: state
  }, props)));
};

function makeTransitionBase(transitionProperty) {
  return {
    transitionProperty: transitionProperty,
    transitionDuration: transitionDuration,
    transitionTimingFunction: transitionTimingFunction
  };
}

const fade = transitionState => _objectSpread({}, makeTransitionBase("opacity"), {
  opacity: {
    entering: 1,
    entered: 1,
    exiting: 0,
    exited: 0
  }[transitionState]
}), slideUp = transitionState => {
  const out = {
    opacity: 0,
    transform: "scale(0.95) translate3d(0,20px,0)"
  };
  return _objectSpread({}, makeTransitionBase("opacity, transform"), {}, {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
}, slideDown = function(transitionState) {
  let {from: from = "-8px"} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const out = {
    opacity: 0,
    transform: "translate3d(0,".concat(from, ",0)")
  };
  return _objectSpread({}, makeTransitionBase("opacity, transform"), {}, {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
}, fromMap = {
  left: "-100%",
  right: "100%"
}, slideInHorizontal = (transitionState, _ref3) => {
  let {slideInFrom: slideInFrom} = _ref3;
  const initial = fromMap[slideInFrom];
  return _objectSpread({}, makeTransitionBase("transform"), {}, {
    entering: {
      transform: "translate3d(0,0,0)"
    },
    entered: {
      transform: "translate3d(0,0,0)"
    },
    exiting: {
      transform: "translate3d(".concat(initial, ", 0, 0)")
    },
    exited: {
      transform: "translate3d(".concat(initial, ", 0, 0)")
    }
  }[transitionState]);
}, zoomInDown = transitionState => _objectSpread({
  transformOrigin: "top",
  transitionProperty: "opacity, transform",
  transitionDuration: transitionDuration,
  transitionTimingFunction: transitionTimingFunction
}, {
  entering: {
    opacity: 1,
    transform: "translate3d(0, 0, 0)"
  },
  entered: {
    opacity: 1,
    transform: "translate3d(0, 0, 0)"
  },
  exiting: {
    opacity: 0,
    transform: "scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)"
  },
  exited: {
    opacity: 0,
    transform: "scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)"
  }
}[transitionState]), springDown = transitionState => _objectSpread({
  transformOrigin: "top",
  transitionProperty: "opacity, transform",
  transitionDuration: transitionDuration,
  transitionTimingFunction: "cubic-bezier(0.2, 0, 0.16, 1.6)"
}, {
  entering: {
    opacity: 1,
    transform: "translate3d(0, 0, 0)"
  },
  entered: {
    opacity: 1,
    transform: "translate3d(0, 0, 0)"
  },
  exiting: {
    opacity: 0,
    transform: "scale(0.93) translate3d(0, -12px, 0)"
  },
  exited: {
    opacity: 0,
    transform: "scale(0.93) translate3d(0, -12px, 0)"
  }
}[transitionState]), Blanket = _ref => {
  let {isTinted: isTinted, isLight: isLight} = _ref, props = _objectWithoutProperties(_ref, [ "isTinted", "isLight" ]), bg = "transparent";
  return isTinted && (bg = isLight ? "rgba(255, 255, 255, 0.5)" : colorUtils.alpha(theme.colors.N100, .2)), 
  core.jsx("div", _extends({
    css: {
      backgroundColor: bg,
      bottom: 0,
      left: 0,
      position: "fixed",
      right: 0,
      top: 0,
      zIndex: 2
    }
  }, props));
};

function getDisplayName(C) {
  return "withModalHandlers(".concat(C.displayName || C.name || "Component", ")");
}

const NOOP = () => {};

let Target = React.memo((function(_ref) {
  let {isOpen: isOpen, mode: mode, target: target, targetRef: targetRef, open: open, toggle: toggle} = _ref;
  const cloneProps = {
    isActive: isOpen,
    ref: targetRef
  };
  return "click" === mode && (cloneProps.onClick = toggle), "contextmenu" === mode && (cloneProps.onContextMenu = open), 
  target(cloneProps);
}));

function withModalHandlers(WrappedComponent, _ref2) {
  let {transition: transition} = _ref2;
  class IntermediateComponent extends React.Component {
    constructor() {
      super(...arguments), _defineProperty(this, "state", {
        isOpen: this.props.defaultIsOpen,
        clientX: 0,
        clientY: 0
      }), _defineProperty(this, "open", event => {
        if (event.defaultPrevented) return;
        "contextmenu" === this.props.mode && event.preventDefault();
        const {clientX: clientX, clientY: clientY} = event;
        this.setState({
          isOpen: !0,
          clientX: clientX,
          clientY: clientY
        }), document.addEventListener("mousedown", this.handleMouseDown), document.addEventListener("keydown", this.handleKeyDown, !1);
      }), _defineProperty(this, "close", event => {
        event && event.defaultPrevented || (this.setState({
          isOpen: !1,
          clientX: 0,
          clientY: 0
        }), document.removeEventListener("mousedown", this.handleMouseDown), document.removeEventListener("keydown", this.handleKeyDown, !1));
      }), _defineProperty(this, "toggle", event => {
        this.state.isOpen ? this.close(event) : this.open(event);
      }), _defineProperty(this, "handleScroll", event => {
        event.preventDefault();
      }), _defineProperty(this, "handleMouseDown", event => {
        const {target: target} = event, {isOpen: isOpen} = this.state;
        (target instanceof HTMLElement || target instanceof SVGElement) && (!isOpen || this.contentNode.contains(target) || this.targetNode.contains(target) || this.close(event));
      }), _defineProperty(this, "handleKeyDown", event => {
        const {key: key} = event;
        "Escape" === key && this.close(event);
      }), _defineProperty(this, "getTarget", ref => {
        this.targetNode = ref;
      }), _defineProperty(this, "getContent", ref => {
        this.contentNode = ref;
      });
    }
    render() {
      const {mode: mode, onClose: onClose, onOpen: onOpen, target: target} = this.props, {clientX: clientX, clientY: clientY, isOpen: isOpen} = this.state;
      return React__default.createElement(React.Fragment, null, React__default.createElement(Target, {
        targetRef: this.getTarget,
        target: target,
        mode: mode,
        isOpen: isOpen,
        toggle: this.toggle,
        open: this.open
      }), isOpen ? React__default.createElement(ScrollLock, null) : null, React__default.createElement(TransitionProvider, {
        isOpen: isOpen,
        onEntered: onOpen,
        onExited: onClose
      }, transitionState => React__default.createElement(WrappedComponent, _extends({
        close: this.close,
        open: this.open,
        getModalRef: this.getContent,
        targetNode: this.targetNode,
        contentNode: this.contentNode,
        isOpen: isOpen,
        mouseCoords: {
          clientX: clientX,
          clientY: clientY
        },
        style: transition(transitionState)
      }, this.props))));
    }
  }
  return _defineProperty(IntermediateComponent, "defaultProps", {
    mode: "click",
    onClose: NOOP,
    onOpen: NOOP
  }), IntermediateComponent.displayName = getDisplayName(WrappedComponent), IntermediateComponent;
}

function generateUEID() {
  let first = 46656 * Math.random() | 0, second = 46656 * Math.random() | 0;
  return (first = ("000" + first.toString(36)).slice(-3)) + (second = ("000" + second.toString(36)).slice(-3));
}

exports.Blanket = Blanket, exports.TransitionProvider = TransitionProvider, exports.fade = fade, 
exports.generateUEID = generateUEID, exports.slideDown = slideDown, exports.slideInHorizontal = slideInHorizontal, 
exports.slideUp = slideUp, exports.springDown = springDown, exports.withModalHandlers = withModalHandlers, 
exports.withTransitionState = withTransitionState, exports.zoomInDown = zoomInDown;
