import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import React, { memo, Component, Fragment } from 'react';
import { TransitionGroup, Transition } from 'react-transition-group';
import { jsx } from '@emotion/core';
import { colors } from '@arch-ui/theme';
import { alpha } from '@arch-ui/color-utils';
import ScrollLock from 'react-scrolllock';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const transitionDurationMs = 220;
const transitionDuration = "".concat(transitionDurationMs, "ms");
const transitionTimingFunction = 'cubic-bezier(0.2, 0, 0, 1)';
const TransitionProvider = (_ref) => {
  let {
    children,
    isOpen
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children", "isOpen"]);

  return React.createElement(TransitionGroup, {
    component: null
  }, isOpen ? React.createElement(Transition, _extends({
    appear: true,
    mountOnEnter: true,
    unmountOnExit: true,
    timeout: transitionDurationMs
  }, props), state => children(state)) : null);
};
const withTransitionState = Comp => (_ref2) => {
  let {
    isOpen
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["isOpen"]);

  return React.createElement(TransitionProvider, {
    isOpen: Boolean(isOpen)
  }, state => React.createElement(Comp, _extends({
    transitionState: state
  }, props)));
}; // ==============================
// Transitions
// ==============================

function makeTransitionBase(transitionProperty) {
  return {
    transitionProperty,
    transitionDuration,
    transitionTimingFunction
  };
}

const fade = transitionState => _objectSpread({}, makeTransitionBase('opacity'), {
  opacity: {
    entering: 1,
    entered: 1,
    exiting: 0,
    exited: 0
  }[transitionState]
}); // Slide Up
// ------------------------------

const slideUp = transitionState => {
  const out = {
    opacity: 0,
    transform: 'scale(0.95) translate3d(0,20px,0)'
  };
  return _objectSpread({}, makeTransitionBase('opacity, transform'), {}, {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
};
const slideDown = function slideDown(transitionState) {
  let {
    from = '-8px'
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const out = {
    opacity: 0,
    transform: "translate3d(0,".concat(from, ",0)")
  };
  return _objectSpread({}, makeTransitionBase('opacity, transform'), {}, {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
};
const fromMap = {
  left: '-100%',
  right: '100%'
}; // NOTE: should be able to use $Keys<typeof fromMap>

const slideInHorizontal = (transitionState, _ref3) => {
  let {
    slideInFrom
  } = _ref3;
  const initial = fromMap[slideInFrom];
  return _objectSpread({}, makeTransitionBase('transform'), {}, {
    entering: {
      transform: 'translate3d(0,0,0)'
    },
    entered: {
      transform: 'translate3d(0,0,0)'
    },
    exiting: {
      transform: "translate3d(".concat(initial, ", 0, 0)")
    },
    exited: {
      transform: "translate3d(".concat(initial, ", 0, 0)")
    }
  }[transitionState]);
};
const zoomInDown = transitionState => {
  return _objectSpread({
    transformOrigin: 'top',
    transitionProperty: 'opacity, transform',
    transitionDuration,
    transitionTimingFunction
  }, {
    entering: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    entered: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    exiting: {
      opacity: 0,
      transform: 'scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)'
    },
    exited: {
      opacity: 0,
      transform: 'scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)'
    }
  }[transitionState]);
};
const springDown = transitionState => {
  return _objectSpread({
    transformOrigin: 'top',
    transitionProperty: 'opacity, transform',
    transitionDuration,
    transitionTimingFunction: 'cubic-bezier(0.2, 0, 0.16, 1.6)'
  }, {
    entering: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    entered: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    exiting: {
      opacity: 0,
      transform: 'scale(0.93) translate3d(0, -12px, 0)'
    },
    exited: {
      opacity: 0,
      transform: 'scale(0.93) translate3d(0, -12px, 0)'
    }
  }[transitionState]);
};

const Blanket = (_ref) => {
  let {
    isTinted,
    isLight
  } = _ref,
      props = _objectWithoutProperties(_ref, ["isTinted", "isLight"]);

  let bg = 'transparent';

  if (isTinted) {
    bg = isLight ? 'rgba(255, 255, 255, 0.5)' : alpha(colors.N100, 0.2);
  }

  return jsx("div", _extends({
    css: {
      backgroundColor: bg,
      bottom: 0,
      left: 0,
      position: 'fixed',
      right: 0,
      top: 0,
      zIndex: 2
    }
  }, props));
};

function getDisplayName(C) {
  return "withModalHandlers(".concat(C.displayName || C.name || 'Component', ")");
}

const NOOP = () => {};

let Target = memo(function Target(_ref) {
  let {
    isOpen,
    mode,
    target,
    targetRef,
    open,
    toggle
  } = _ref;
  const cloneProps = {
    isActive: isOpen,
    ref: targetRef
  };
  if (mode === 'click') cloneProps.onClick = toggle;
  if (mode === 'contextmenu') cloneProps.onContextMenu = open;
  return target(cloneProps);
});
function withModalHandlers(WrappedComponent, _ref2) {
  let {
    transition
  } = _ref2;

  class IntermediateComponent extends Component {
    constructor() {
      super(...arguments);

      _defineProperty(this, "state", {
        isOpen: this.props.defaultIsOpen,
        clientX: 0,
        clientY: 0
      });

      _defineProperty(this, "open", event => {
        if (event.defaultPrevented) return;
        if (this.props.mode === 'contextmenu') event.preventDefault();
        const {
          clientX,
          clientY
        } = event;
        this.setState({
          isOpen: true,
          clientX,
          clientY
        });
        document.addEventListener('mousedown', this.handleMouseDown);
        document.addEventListener('keydown', this.handleKeyDown, false);
      });

      _defineProperty(this, "close", event => {
        if (event && event.defaultPrevented) return;
        this.setState({
          isOpen: false,
          clientX: 0,
          clientY: 0
        });
        document.removeEventListener('mousedown', this.handleMouseDown);
        document.removeEventListener('keydown', this.handleKeyDown, false);
      });

      _defineProperty(this, "toggle", event => {
        if (this.state.isOpen) {
          this.close(event);
        } else {
          this.open(event);
        }
      });

      _defineProperty(this, "handleScroll", event => {
        event.preventDefault();
      });

      _defineProperty(this, "handleMouseDown", event => {
        const {
          target
        } = event;
        const {
          isOpen
        } = this.state;

        if (!(target instanceof HTMLElement) && !(target instanceof SVGElement)) {
          return;
        } // NOTE: Why not use the <Blanket /> component to close?
        // We don't want to interupt the user's flow. Taking this approach allows
        // user to click "through" to other elements and close the popout.


        if (isOpen && !this.contentNode.contains(target) && !this.targetNode.contains(target)) {
          this.close(event);
        }
      });

      _defineProperty(this, "handleKeyDown", event => {
        const {
          key
        } = event;

        if (key === 'Escape') {
          this.close(event);
        }
      });

      _defineProperty(this, "getTarget", ref => {
        this.targetNode = ref;
      });

      _defineProperty(this, "getContent", ref => {
        this.contentNode = ref;
      });
    }

    render() {
      const {
        mode,
        onClose,
        onOpen,
        target
      } = this.props;
      const {
        clientX,
        clientY,
        isOpen
      } = this.state;
      return React.createElement(Fragment, null, React.createElement(Target, {
        targetRef: this.getTarget,
        target: target,
        mode: mode,
        isOpen: isOpen,
        toggle: this.toggle,
        open: this.open
      }), isOpen ? React.createElement(ScrollLock, null) : null, React.createElement(TransitionProvider, {
        isOpen: isOpen,
        onEntered: onOpen,
        onExited: onClose
      }, transitionState => React.createElement(WrappedComponent, _extends({
        close: this.close,
        open: this.open,
        getModalRef: this.getContent,
        targetNode: this.targetNode,
        contentNode: this.contentNode,
        isOpen: isOpen,
        mouseCoords: {
          clientX,
          clientY
        },
        style: transition(transitionState)
      }, this.props))));
    }

  }

  _defineProperty(IntermediateComponent, "defaultProps", {
    mode: 'click',
    onClose: NOOP,
    onOpen: NOOP
  });

  IntermediateComponent.displayName = getDisplayName(WrappedComponent);
  return IntermediateComponent;
}

function generateUEID() {
  let first = Math.random() * 46656 | 0;
  let second = Math.random() * 46656 | 0;
  first = ('000' + first.toString(36)).slice(-3);
  second = ('000' + second.toString(36)).slice(-3);
  return first + second;
}

export { Blanket, TransitionProvider, fade, generateUEID, slideDown, slideInHorizontal, slideUp, springDown, withModalHandlers, withTransitionState, zoomInDown };
