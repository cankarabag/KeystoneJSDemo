import _extends from '@babel/runtime/helpers/esm/extends';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import { forwardRef, Component } from 'react';
import { createPortal } from 'react-dom';
import { borderRadius, shadows, gridSize, colors } from '@arch-ui/theme';
import { FocusTrap } from 'react-focus-marshal';
import { withModalHandlers, springDown } from '@arch-ui/modal-utils';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const ARROW_WIDTH = 30;
const CHROME_GUTTER = 30;
const Wrapper = forwardRef((_ref, ref) => {
  let {
    left,
    top,
    width
  } = _ref,
      props = _objectWithoutProperties(_ref, ["left", "top", "width"]);

  const placementStyles = {
    left,
    top,
    width
  };
  return jsx("div", _extends({
    ref: ref,
    css: _objectSpread({
      backgroundColor: 'white',
      borderRadius: borderRadius * 2,
      boxShadow: shadows[2],
      marginTop: gridSize * 2,
      maxHeight: '100%',
      position: 'absolute',
      zIndex: 2
    }, placementStyles)
  }, props));
});

const WrapperInner = props => jsx("div", _extends({
  css: {
    position: 'relative'
  }
}, props));

const Arrow = (_ref2) => {
  let {
    left
  } = _ref2;
  return jsx("div", {
    css: {
      height: ARROW_WIDTH,
      left: left,
      marginLeft: -ARROW_WIDTH / 2,
      marginTop: -11,
      position: 'absolute',
      width: ARROW_WIDTH
    }
  }, jsx("svg", {
    viewBox: "0 0 30 30",
    style: {
      transform: 'rotate(90deg)'
    },
    focusable: "false",
    role: "presentation"
  }, jsx("path", {
    css: {
      fill: colors.text,
      fillOpacity: 0.1
    },
    d: "M8.11 6.302c1.015-.936 1.887-2.922 1.887-4.297v26c0-1.378-.868-3.357-1.888-4.297L.925 17.09c-1.237-1.14-1.233-3.034 0-4.17L8.11 6.302z"
  }), jsx("path", {
    css: {
      fill: 'white'
    },
    d: "M8.787 7.036c1.22-1.125 2.21-3.376 2.21-5.03V0v30-2.005c0-1.654-.983-3.9-2.21-5.03l-7.183-6.616c-.81-.746-.802-1.96 0-2.7l7.183-6.614z"
  })));
};

class Popout extends Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      leftOffset: 0,
      topOffset: 0,
      arrowLeftOffset: '0'
    });

    _defineProperty(this, "calculatePosition", () => {
      const {
        targetNode,
        width
      } = this.props;
      if (!targetNode || !document.body) return; // prepare common values

      const bodyRect = document.body.getBoundingClientRect();
      const targetRect = targetNode.getBoundingClientRect();
      const targetCenter = targetRect.left + targetRect.width / 2;
      let leftOffset = Math.max(targetCenter - width / 2, CHROME_GUTTER);
      let topOffset = targetRect.bottom - bodyRect.top;
      let isAlignedRight = false; // handle right aligned

      const spaceOnRight = window.innerWidth - (leftOffset + width + CHROME_GUTTER);

      if (spaceOnRight < 0) {
        leftOffset = leftOffset + spaceOnRight;
        isAlignedRight = true;
      } // get arrow offset


      let arrowLeftOffset = '50%';

      if (leftOffset === CHROME_GUTTER) {
        arrowLeftOffset = "".concat(targetCenter - ARROW_WIDTH / 2 - CHROME_GUTTER, "px");
      }

      if (isAlignedRight) {
        arrowLeftOffset = "".concat(targetCenter - leftOffset, "px");
      } // avoid state thrashing


      const newStateAvaliable = this.state.leftOffset !== leftOffset || this.state.topOffset !== topOffset || this.state.arrowLeftOffset !== arrowLeftOffset;

      if (newStateAvaliable) {
        this.setState({
          leftOffset,
          topOffset,
          arrowLeftOffset
        });
      }
    });
  }

  componentDidMount() {
    window.addEventListener('resize', this.calculatePosition);
    this.calculatePosition();
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.calculatePosition);
  }

  render() {
    const {
      children,
      getModalRef,
      style,
      width
    } = this.props;
    let {
      leftOffset,
      topOffset,
      arrowLeftOffset
    } = this.state;
    const attachTo = typeof document !== 'undefined' ? document.body : null;
    return attachTo ? createPortal(jsx(Wrapper, {
      ref: getModalRef,
      left: leftOffset,
      top: topOffset,
      width: width,
      style: style // style comes from Transition

    }, jsx(FocusTrap, {
      options: {
        clickOutsideDeactivates: true
      }
    }, jsx(WrapperInner, null, jsx(Arrow, {
      left: arrowLeftOffset
    }), children))), attachTo) : null;
  }

}

_defineProperty(Popout, "defaultProps", {
  width: 320
});

var index = withModalHandlers(Popout, {
  transition: springDown
});

export default index;
