"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _extends = _interopDefault(require("@babel/runtime/helpers/extends")), _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), core = require("@emotion/core"), react = require("react"), reactDom = require("react-dom"), theme = require("@arch-ui/theme"), reactFocusMarshal = require("react-focus-marshal"), modalUtils = require("@arch-ui/modal-utils");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const ARROW_WIDTH = 30, CHROME_GUTTER = 30, Wrapper = react.forwardRef((_ref, ref) => {
  let {left: left, top: top, width: width} = _ref, props = _objectWithoutProperties(_ref, [ "left", "top", "width" ]);
  const placementStyles = {
    left: left,
    top: top,
    width: width
  };
  return core.jsx("div", _extends({
    ref: ref,
    css: _objectSpread({
      backgroundColor: "white",
      borderRadius: 2 * theme.borderRadius,
      boxShadow: theme.shadows[2],
      marginTop: 2 * theme.gridSize,
      maxHeight: "100%",
      position: "absolute",
      zIndex: 2
    }, placementStyles)
  }, props));
}), WrapperInner = props => core.jsx("div", _extends({
  css: {
    position: "relative"
  }
}, props)), Arrow = _ref2 => {
  let {left: left} = _ref2;
  return core.jsx("div", {
    css: {
      height: ARROW_WIDTH,
      left: left,
      marginLeft: -ARROW_WIDTH / 2,
      marginTop: -11,
      position: "absolute",
      width: ARROW_WIDTH
    }
  }, core.jsx("svg", {
    viewBox: "0 0 30 30",
    style: {
      transform: "rotate(90deg)"
    },
    focusable: "false",
    role: "presentation"
  }, core.jsx("path", {
    css: {
      fill: theme.colors.text,
      fillOpacity: .1
    },
    d: "M8.11 6.302c1.015-.936 1.887-2.922 1.887-4.297v26c0-1.378-.868-3.357-1.888-4.297L.925 17.09c-1.237-1.14-1.233-3.034 0-4.17L8.11 6.302z"
  }), core.jsx("path", {
    css: {
      fill: "white"
    },
    d: "M8.787 7.036c1.22-1.125 2.21-3.376 2.21-5.03V0v30-2.005c0-1.654-.983-3.9-2.21-5.03l-7.183-6.616c-.81-.746-.802-1.96 0-2.7l7.183-6.614z"
  })));
};

class Popout extends react.Component {
  constructor() {
    super(...arguments), _defineProperty(this, "state", {
      leftOffset: 0,
      topOffset: 0,
      arrowLeftOffset: "0"
    }), _defineProperty(this, "calculatePosition", () => {
      const {targetNode: targetNode, width: width} = this.props;
      if (!targetNode || !document.body) return;
      const bodyRect = document.body.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), targetCenter = targetRect.left + targetRect.width / 2;
      let leftOffset = Math.max(targetCenter - width / 2, CHROME_GUTTER), topOffset = targetRect.bottom - bodyRect.top, isAlignedRight = !1;
      const spaceOnRight = window.innerWidth - (leftOffset + width + CHROME_GUTTER);
      spaceOnRight < 0 && (leftOffset += spaceOnRight, isAlignedRight = !0);
      let arrowLeftOffset = "50%";
      leftOffset === CHROME_GUTTER && (arrowLeftOffset = "".concat(targetCenter - ARROW_WIDTH / 2 - CHROME_GUTTER, "px")), 
      isAlignedRight && (arrowLeftOffset = "".concat(targetCenter - leftOffset, "px")), 
      (this.state.leftOffset !== leftOffset || this.state.topOffset !== topOffset || this.state.arrowLeftOffset !== arrowLeftOffset) && this.setState({
        leftOffset: leftOffset,
        topOffset: topOffset,
        arrowLeftOffset: arrowLeftOffset
      });
    });
  }
  componentDidMount() {
    window.addEventListener("resize", this.calculatePosition), this.calculatePosition();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.calculatePosition);
  }
  render() {
    const {children: children, getModalRef: getModalRef, style: style, width: width} = this.props;
    let {leftOffset: leftOffset, topOffset: topOffset, arrowLeftOffset: arrowLeftOffset} = this.state;
    const attachTo = "undefined" != typeof document ? document.body : null;
    return attachTo ? reactDom.createPortal(core.jsx(Wrapper, {
      ref: getModalRef,
      left: leftOffset,
      top: topOffset,
      width: width,
      style: style
    }, core.jsx(reactFocusMarshal.FocusTrap, {
      options: {
        clickOutsideDeactivates: !0
      }
    }, core.jsx(WrapperInner, null, core.jsx(Arrow, {
      left: arrowLeftOffset
    }), children))), attachTo) : null;
  }
}

_defineProperty(Popout, "defaultProps", {
  width: 320
});

var index = modalUtils.withModalHandlers(Popout, {
  transition: modalUtils.springDown
});

exports.default = index;
