import React, { memo, Fragment, forwardRef } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { uniformHeight } from '@arch-ui/common';
import { colors } from '@arch-ui/theme';

// ------------------------------

const HiddenInput = (_ref) => {
  let {
    innerRef
  } = _ref,
      props = _objectWithoutProperties(_ref, ["innerRef"]);

  return jsx("input", _extends({
    ref: innerRef,
    tabIndex: "-1",
    css: {
      border: 0,
      clip: 'rect(1px, 1px, 1px, 1px)',
      height: 1,
      margin: 0,
      opacity: 0,
      overflow: 'hidden',
      padding: 0,
      position: 'absolute',
      whiteSpace: 'nowrap',
      width: 1
    }
  }, props));
};

// ==============================

/*
 *  Why?
 *  ------------------------------
 *  For a while now browsers have been ignoring the `autocomplete="off"`
 *  property on form and input elements:
 *  - https://bugs.chromium.org/p/chromium/issues/detail?id=468153#c164
 *
 *  How?
 *  ------------------------------
 *  Browsers will autocomplete inputs in the order they're encountered; this
 *  component will capture the browser's attempt to autocomplete into these
 *  two hidden inputs and leave your legitimate fields unpolluted.
 *
 *  NOTE
 *  ------------------------------
 *  This component *must* be rendered before your legitimate fields.
 */

const AutocompleteCaptor = memo(function AutocompleteCaptor() {
  return React.createElement(Fragment, null, React.createElement(HiddenInput, {
    autoComplete: "username",
    type: "text",
    tabIndex: -1
  }), React.createElement(HiddenInput, {
    autoComplete: "email",
    type: "text",
    tabIndex: -1
  }), React.createElement(HiddenInput, {
    autoComplete: "current-password",
    type: "password",
    tabIndex: -1
  }), React.createElement(HiddenInput, {
    autoComplete: "new-password",
    type: "password",
    tabIndex: -1
  }));
}, () => true);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// Basic Input
// ------------------------------

const inputStyles = function inputStyles() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread({}, uniformHeight, {
    backgroundColor: props.disabled ? colors.N10 : 'white',
    borderColor: colors.N20,
    color: 'inherit',
    width: '100%',
    ':hover': {
      borderColor: colors.N30,
      outline: 0
    },
    ':focus': {
      borderColor: colors.primary,
      outline: 0
    },
    '&[disabled]': {
      borderColor: colors.N15,
      backgroundColor: colors.N05
    }
  }, props.isMultiline ? {
    lineHeight: 'inherit',
    minHeight: 100,
    resize: 'vertical',
    whiteSpace: 'wrap'
  } : undefined);
};
const Input = forwardRef((props, ref) => {
  const {
    isMultiline
  } = props,
        inputProps = _objectWithoutProperties(props, ["isMultiline"]);

  const Component = isMultiline ? 'textarea' : 'input';
  return jsx(Component, _extends({
    ref: ref,
    css: inputStyles(props)
  }, inputProps));
});

export { AutocompleteCaptor, HiddenInput, Input, inputStyles };
