"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), react = require("react"), reactRouterDom = require("react-router-dom"), reactDom = require("react-dom"), styled = _interopDefault(require("@emotion/styled")), core = require("@emotion/core"), theme = require("@arch-ui/theme"), reactFocusMarshal = require("react-focus-marshal"), modalUtils = require("@arch-ui/modal-utils");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const ItemElement = props => props.to ? core.jsx(reactRouterDom.Link, props) : props.href ? core.jsx("a", props) : core.jsx("button", _extends({
  type: "button"
}, props)), ItemInner = _ref => {
  let {children: children, icon: icon} = _ref;
  return icon ? core.jsx("div", {
    css: {
      alignItems: "center",
      display: "flex",
      lineHeight: 1
    }
  }, core.jsx("div", {
    key: "icon",
    css: {
      marginRight: theme.gridSize,
      width: 16,
      textAlign: "center"
    }
  }, icon), core.jsx("div", {
    key: "children",
    css: {
      flex: 1
    }
  }, children)) : children;
}, Item = _ref2 => {
  let {children: children, icon: icon, isDisabled: isDisabled} = _ref2, props = _objectWithoutProperties(_ref2, [ "children", "icon", "isDisabled" ]);
  return core.jsx(ItemElement, _extends({
    disabled: isDisabled,
    css: {
      appearance: "none",
      background: "none",
      border: "1px solid transparent",
      boxSizing: "border-box",
      color: isDisabled ? theme.colors.N40 : theme.colors.text,
      cursor: "pointer",
      display: "block",
      fontSize: 14,
      lineHeight: "17px",
      margin: 0,
      padding: "".concat(theme.gridSize, "px ").concat(1.5 * theme.gridSize, "px"),
      pointerEvents: isDisabled ? "none" : null,
      textAlign: "left",
      transition: "box-shadow 100ms linear",
      verticalAlign: "middle",
      whiteSpace: "nowrap",
      width: "100%",
      "&:hover, &:focus": {
        backgroundColor: theme.colors.B.L90,
        color: theme.colors.primary,
        outline: 0,
        textDecoration: "none"
      }
    }
  }, props), core.jsx(ItemInner, {
    icon: icon
  }, children));
}, Menu = styled.div(_ref3 => {
  let {left: left, top: top} = _ref3;
  const placementStyles = {
    left: left,
    top: top
  };
  return _objectSpread({
    backgroundColor: "white",
    borderRadius: theme.borderRadius,
    boxShadow: theme.shadows[2],
    marginTop: theme.gridSize,
    minWidth: 160,
    paddingBottom: theme.gridSize / 2,
    paddingTop: theme.gridSize / 2,
    position: "absolute",
    zIndex: 2
  }, placementStyles);
});

function focus(el) {
  el && el instanceof HTMLElement && "function" == typeof el.focus && el.focus();
}

class Dropdown extends react.Component {
  constructor() {
    super(...arguments), _defineProperty(this, "state", {
      leftOffset: 0,
      topOffset: 0
    }), _defineProperty(this, "handleItemClick", _ref4 => {
      let {onClick: onClick} = _ref4, data = _objectWithoutProperties(_ref4, [ "onClick" ]);
      return event => {
        const {close: close, selectClosesMenu: selectClosesMenu} = this.props;
        selectClosesMenu && close(event), onClick && onClick({
          event: event,
          data: data
        });
      };
    }), _defineProperty(this, "handleKeyDown", event => {
      const {key: key, target: target} = event;
      if (!(target instanceof HTMLElement)) return;
      if (-1 === [ "ArrowUp", "ArrowDown", "PageUp", "PageDown" ].indexOf(key)) return;
      event.preventDefault();
      const isArrowUp = "ArrowUp" === key, isArrowDown = "ArrowDown" === key, isPageUp = "PageUp" === key, isPageDown = "PageDown" === key, firstItem = this.menu.firstChild, lastItem = this.menu.lastChild, previousItem = target.previousSibling, nextItem = target.nextSibling;
      isArrowUp && focus(previousItem), isArrowDown && focus(nextItem), isPageUp && focus(firstItem), 
      isPageDown && focus(lastItem), target === firstItem && isArrowUp && focus(lastItem), 
      target === lastItem && isArrowDown && focus(firstItem);
    }), _defineProperty(this, "handleMouseEnter", _ref5 => {
      let {target: target} = _ref5;
      target instanceof HTMLElement && (this.lastHover = target), document.activeElement && document.activeElement.blur();
    }), _defineProperty(this, "handleMenuLeave", () => {
      focus(this.lastHover);
    }), _defineProperty(this, "getMenu", ref => {
      null !== ref && (this.menu = ref, this.props.getModalRef(ref));
    }), _defineProperty(this, "calculatePosition", () => {
      const {align: align, mode: mode, mouseCoords: mouseCoords, targetNode: targetNode} = this.props;
      if (!targetNode || !document.body) return;
      const bodyRect = document.body.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), menuHeight = this.menu.clientHeight, menuWidth = this.menu.clientWidth;
      let leftOffset = 0, topOffset = 0;
      if ("click" === mode) return leftOffset = "left" === align ? targetRect.left : targetRect.right - menuWidth, 
      topOffset = targetRect.bottom - bodyRect.top, void this.setState({
        leftOffset: leftOffset,
        topOffset: topOffset
      });
      const {clientX: clientX, clientY: clientY} = mouseCoords, right = window.innerWidth - clientX > menuWidth, top = window.innerHeight - clientY > menuHeight, bottom = !top;
      right && (leftOffset = clientX), !right && (leftOffset = clientX - menuWidth), top && (topOffset = clientY - bodyRect.top), 
      bottom && (topOffset = clientY - bodyRect.top - menuHeight), this.setState({
        leftOffset: leftOffset,
        topOffset: topOffset
      });
    });
  }
  componentDidMount() {
    this.calculatePosition(), document.addEventListener("keydown", this.handleKeyDown, !1);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown, !1);
  }
  render() {
    const {items: items, style: style} = this.props, {leftOffset: leftOffset, topOffset: topOffset} = this.state, attachTo = document.body;
    return attachTo ? reactDom.createPortal(core.jsx(reactFocusMarshal.FocusTrap, {
      options: {
        clickOutsideDeactivates: !0
      }
    }, core.jsx(Menu, {
      left: leftOffset,
      onMouseLeave: this.handleMenuLeave,
      ref: this.getMenu,
      style: style,
      top: topOffset
    }, items.map((item, idx) => {
      const {content: content} = item, rest = _objectWithoutProperties(item, [ "content" ]);
      return core.jsx(Item, _extends({}, rest, {
        onClick: this.handleItemClick(item),
        onMouseEnter: this.handleMouseEnter,
        key: idx
      }), content);
    }))), attachTo) : null;
  }
}

_defineProperty(Dropdown, "defaultProps", {
  align: "left",
  selectClosesMenu: !0
});

var index = modalUtils.withModalHandlers(Dropdown, {
  transition: modalUtils.slideDown
});

exports.default = index;
