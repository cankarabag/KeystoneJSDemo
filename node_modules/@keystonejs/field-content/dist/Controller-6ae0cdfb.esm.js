import '@babel/runtime/helpers/esm/objectWithoutProperties';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { captureSuspensePromises } from '@keystonejs/utils';
import './slate-walker-baa7fa30.esm.js';
import { Value } from 'slate';
import 'nanoassert';
import { serialize, deserialize } from '../slate-serializer/dist/field-content.esm.js';
import memoizeOne from 'memoize-one';
import isPromise from 'p-is-promise';
import Controller from '@keystonejs/fields/Controller';
const initialValue = {
  document: {
    nodes: [{
      object: 'block',
      type: 'paragraph',
      nodes: [{
        object: 'text',
        text: ''
      }]
    }]
  }
};

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const flattenBlocks = inputBlocks => inputBlocks.reduce((outputBlocks, block) => {
  if (!block.type) {
    // Some blocks may pull in other views which aren't themselves blocks, so
    // we ignore them here
    return outputBlocks;
  } // NOTE: It's enough to check just the type here as we've already flattened
  // and deduped dependencies during build.


  if (outputBlocks[block.type]) {
    throw new Error("Encountered more than one Content block with type of '".concat(block.type, "'. Content blocks must have globally unique types."));
  }

  if (block.Node === undefined) {
    throw new Error("Unable to load Content block '".concat(block.type, "': no 'Node' export found."));
  }

  outputBlocks[block.type] = block;
  return outputBlocks;
}, {});

class ContentController extends Controller {
  constructor(config) {
    const defaultValue = 'defaultValue' in config ? config.defaultValue : Value.fromJSON(initialValue);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    super(_objectSpread({}, config, {
      defaultValue
    }), ...args); // Attach this as a memoized member function to avoid two pitfalls;
    // 1. Don't load all the block views up front. Instead, lazily load them
    //    only when requested.
    // 2. Avoid recalculating everything on each request for the Blocks.
    //    Instead, when requested multiple times, use the previously cached
    //    results.
    // NOTE: This function is designed to work with React Suspense, so may throw
    // a Promise the first time it is called.

    _defineProperty(this, "getFilterGraphQL", _ref => {
      let {
        type,
        value
      } = _ref;
      const key = type === 'is' ? "".concat(this.path) : "".concat(this.path, "_").concat(type);
      return "".concat(key, ": \"").concat(value, "\"");
    });

    _defineProperty(this, "getFilterLabel", _ref2 => {
      let {
        label
      } = _ref2;
      return "".concat(this.label, " ").concat(label.toLowerCase());
    });

    _defineProperty(this, "formatFilter", _ref3 => {
      let {
        label,
        value
      } = _ref3;
      return "".concat(this.getFilterLabel({
        label
      }), ": \"").concat(value, "\"");
    });

    _defineProperty(this, "getFilterTypes", () => [{
      type: 'contains',
      label: 'Contains',
      getInitialValue: () => ''
    }, {
      type: 'not_contains',
      label: 'Does not contain',
      getInitialValue: () => ''
    }]);

    _defineProperty(this, "getBlocksSync", () => {
      // May return synchronously, or may throw with either an actual error or a
      // loading promise. We should never see a Promise thrown as .serialize()
      // only gets called during event handlers on the client _after_ all the
      // React Suspense calls are fully resolved. We want the
      // returns-synchronously case. Otherwise, we want to either rethrow any
      // error thrown, or throw a new error indicating an unexpected Promise was
      // thrown.
      try {
        return this.getBlocks();
      } catch (loadingPromiseOrError) {
        if (isPromise(loadingPromiseOrError)) {
          // `.getBlocks()` thinks it's in React Suspense mode, which we can't
          // handle here, so we throw a new error.
          throw new Error('`Content#getBlocks()` threw a Promise. This may occur when calling `Content#(de)serialize()` before blocks have had a chance to fully load.');
        } // An actual error occurred


        throw loadingPromiseOrError;
      }
    });

    _defineProperty(this, "serialize", data => {
      const {
        path
      } = this;

      if (!data[path] || !data[path].document) {
        // Forcibly return null if empty string
        return {
          document: null
        };
      }

      const blocks = this.getBlocksSync();
      const serializedDocument = serialize(data[path], blocks); // TODO: Make this a JSON type in GraphQL so we don't have to stringify it.

      serializedDocument.document = JSON.stringify(serializedDocument.document);
      return {
        disconnectAll: true,
        create: serializedDocument
      };
    });

    _defineProperty(this, "deserialize", data => {
      const {
        path
      } = this;

      if (!data[path] || !data[path].document) {
        // Forcibly return a default value if nothing set
        return Value.fromJSON(initialValue);
      }

      const blocks = this.getBlocksSync(); // TODO: Make the .document a JSON type in GraphQL so we don't have to parse
      // it

      const parsedData = _objectSpread({}, data[path], {
        document: JSON.parse(data[path].document)
      });

      return deserialize(parsedData, blocks);
    });

    _defineProperty(this, "getQueryFragment", () => "\n    ".concat(this.path, " {\n      document\n      ").concat(Object.values(this.config.blockOptions).map(_ref4 => {
      let {
        query
      } = _ref4;
      return query;
    }).filter(Boolean).join('\n'), "\n    }\n  "));

    _defineProperty(this, "initFieldView", () => {
      captureSuspensePromises([() => {
        const {
          Field
        } = this.views;

        if (!Field) {
          return;
        }

        this.adminMeta.readViews([Field]);
      }, () => this.getBlocks()]);
    });

    _defineProperty(this, "initCellView", () => {
      captureSuspensePromises([() => {
        const {
          Cell
        } = this.views;

        if (!Cell) {
          return;
        }

        this.adminMeta.readViews([Cell]);
      }, () => this.getBlocks()]);
    });

    _defineProperty(this, "initFilterView", () => {
      captureSuspensePromises([() => {
        const {
          Filter
        } = this.views;

        if (!Filter) {
          return;
        }

        this.adminMeta.readViews([Filter]);
      }, () => this.getBlocks()]);
    });

    this.getBlocks = memoizeOne(() => {
      // Loads all configured blocks and their dependencies
      const blocksModules = this.adminMeta.readViews(this.views.blocks);
      const customBlocks = blocksModules.map(block => _objectSpread({}, block, {
        options: _objectSpread({}, this.config.blockOptions[block.type], {
          adminMeta: this.adminMeta
        }),
        // This block exists because it was passed into the Content field
        // directly.
        // Dependencies are not allowed to show UI chrome (toolbar/sidebar) unless
        // they're also directly passed to the Content Field.
        withChrome: this.config.blockTypes.includes(block.type)
      }));
      return flattenBlocks(customBlocks);
    });
  }

}

export default ContentController;
