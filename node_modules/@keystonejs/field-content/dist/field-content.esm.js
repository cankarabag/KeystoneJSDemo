import { join as _join } from "path";
import { Relationship, Text } from '@keystonejs/fields';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import getByPath from 'lodash.get';
import { objMerge, unique, flatMap } from '@keystonejs/utils';
import '../Block/dist/field-content.esm.js';
import { paragraph as ParagraphBlock, blockquote as BlockquoteBlock, heading as HeadingBlock, imageContainer as ImageContainerBlock, link as LinkBlock, orderedList as OrderedListBlock, unorderedList as UnorderedListBlock } from '../blocks/dist/field-content.esm.js';
import { w as walkSlateNode } from './slate-walker-baa7fa30.esm.js';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const GQL_TYPE_PREFIX = '_ContentType';
const DEFAULT_BLOCKS = [[ParagraphBlock, {}]];
/**
 * @param data Object For example:
 * {
 *   document: [
 *     { object: 'block', type: 'cloudinaryImage', data: { _mutationPath: 'cloudinaryImages.create[0]' },
 *     { object: 'block', type: 'cloudinaryImage', data: { _mutationPath: 'cloudinaryImages.create[1]' },
 *     { object: 'block', type: 'relationshipUser', data: { _mutationPath: 'relationshipUsers.create[0]' } }
 *     { object: 'block', type: 'relationshipUser', data: { _mutationPath: 'relationshipUsers.connect[0]' } }
 *   ],
 *   cloudinaryImages: {
 *     create: [
 *       { data: { image: <FileObject>, align: 'center' } },
 *       { data: { image: <FileObject>, align: 'center' } }
 *     ]
 *   },
 *   relationshipUsers: {
 *     create: [{ data: { id: 'abc123' } }],
 *     connect: [{ id: 'xyz789' }],
 *   },
 * }
 */

async function processSerialised(document, blocks, graphQlArgs) {
  // Each block retreives its mutations
  const resolvedMutations = blocks.reduce((mutations, block) => _objectSpread({}, mutations, {}, block.getMutationOperationResults(graphQlArgs)), {});
  const result = {
    document: walkSlateNode(document, {
      visitBlock(node) {
        if (!node.data || !node.data._mutationPaths) {
          // A regular slate.js node - pass it through
          return node;
        }

        const block = blocks.find(_ref => {
          let {
            type
          } = _ref;
          return type === node.type;
        });

        if (!block) {
          throw new Error("Received mutation for ".concat(node.type, ", but no block types can handle it."));
        }

        const _joinIds = node.data._mutationPaths.map(mutationPath => {
          const joinId = getByPath(resolvedMutations, mutationPath);

          if (!joinId) {
            throw new Error("Slate document refers to unknown mutation '".concat(mutationPath, "'."));
          }

          return joinId;
        }); // NOTE: We don't recurse on the children; we only process the outer
        // most block, any child blocks are left as-is.


        return _objectSpread({}, node, {
          data: {
            _joinIds
          }
        });
      },

      defaultVisitor(node, visitNode) {
        if (node.nodes) {
          // Recurse into the child nodes array
          node.nodes = node.nodes.map(childNode => visitNode(childNode));
        }

        return node;
      }

    })
  };
  return result;
}

class Content extends Relationship.implementation {
  constructor(path, _ref2, listConfig) {
    let {
      blocks: inputBlocks
    } = _ref2,
        fieldConfig = _objectWithoutProperties(_ref2, ["blocks"]); // To maintain consistency with other types, we grab the sanitised name
    // directly from the list.


    const {
      itemQueryName
    } = listConfig.getListByKey(listConfig.listKey).gqlNames; // We prefix with `_` here to avoid any possible conflict with a list called
    // `ContentType`.
    // Including the list name + path to make sure these input types are unique
    // to this list+field and don't collide.

    const type = "".concat(GQL_TYPE_PREFIX, "_").concat(itemQueryName, "_").concat(path); // Normalise blocks to always be a tuple with a config object

    let blocks = (Array.isArray(inputBlocks) ? inputBlocks : []).map(block => Array.isArray(block) ? block : [block, {}]);
    blocks.push(...DEFAULT_BLOCKS);
    const blockInstances = blocks.map(_ref3 => {
      let [block, blockConfig] = _ref3;
      return new block(blockConfig, _objectSpread({
        fromList: listConfig.listKey,
        joinList: type
      }, listConfig));
    }); // Checking for duplicate block types

    for (let currentIndex = 0; currentIndex < blockInstances.length; currentIndex++) {
      const {
        type: currentType
      } = blockInstances[currentIndex];

      for (let checkIndex = currentIndex + 1; checkIndex < blockInstances.length; checkIndex++) {
        const {
          type: checkType
        } = blockInstances[checkIndex];

        if (currentType === checkType) {
          throw new Error("Encountered duplicate Content block type '".concat(currentType, "'."));
        }
      }
    } // Ensure the list is only instantiated once per server instance.


    let auxList = listConfig.getListByKey(type);

    if (!auxList) {
      auxList = listConfig.createAuxList(type, {
        fields: _objectSpread({
          // TODO: Change to a native JSON type
          document: {
            type: Text,
            schemaDoc: 'The serialized Slate.js Document structure'
          },
          // Used to do reverse lookups of Document -> Original Item
          from: {
            type: Relationship,
            ref: "".concat(listConfig.listKey, ".").concat(path),
            schemaDoc: 'A reference back to the item this document belongs to'
          }
        }, objMerge(blockInstances.map(block => block.getFieldDefinitions()))),
        hooks: {
          async resolveInput(_ref4) {
            let {
              resolvedData
            } = _ref4,
                args = _objectWithoutProperties(_ref4, ["resolvedData"]); // This method will get called twice;
            // 1. The incoming graphql request data
            // 2. Registering the back link in the `from` field
            // We only want to handle the first case, so we bail early otherwise


            if (!resolvedData.document) {
              return resolvedData;
            } // TODO: Remove JSON.parse once using native JSON type


            const documentObj = JSON.parse(resolvedData.document);
            const {
              document
            } = await processSerialised(documentObj, blockInstances, args);
            return _objectSpread({}, resolvedData, {
              // TODO: FIXME: Use a JSON type
              document: JSON.stringify(document)
            });
          }

        }
      });
    } // Link up the back reference to keep things in sync


    const config = _objectSpread({}, fieldConfig, {
      many: false,
      ref: "".concat(type, ".from")
    });

    super(path, config, listConfig);
    this.auxList = auxList;
    this.listConfig = listConfig;
    this.blocks = blockInstances;
  }
  /*
   * Blocks come in 2 halves:
   * 1. The block implementation (eg; ./views/editor/blocks/embed.js)
   * 2. The config (eg; { apiKey: process.env.EMBEDLY_API_KEY })
   * Because of the way we bundle the admin UI, we have to split apart these
   * two halves and send them seperately (see `@keystonejs/field-views-loader`):
   * 1. Sent as a "view" (see `extendAdminViews` below), which will be required
   *    (so it's included in the bundle).
   * 2. Sent as a serialized JSON object (see `extendAdminMeta` below), which
   *    will be injected into the `window` and read back ready for use.
   * We then stitch those two halves back together within `views/Field.js`.
   */


  extendAdminMeta(meta) {
    return _objectSpread({}, meta, {
      blockTypes: this.blocks.map(_ref5 => {
        let {
          type
        } = _ref5;
        return type;
      }),
      blockOptions: this.blocks.map(block => [block, block.getViewOptions()]) // Don't bother sending any configs that are empty
      .filter(_ref6 => {
        let [, blockConfig] = _ref6;
        return blockConfig && Object.keys(blockConfig).length;
      }) // Key the block options by type to be serialised and passed to the
      // client
      .reduce((options, block) => _objectSpread({}, options, {
        [block[0].type]: block[1]
      }), {})
    });
  } // Add the blocks config to the views object for usage in the admin UI
  // (ie; { Cell: , Field: , Filters: , blocks: ...})


  extendAdminViews(views) {
    return _objectSpread({}, views, {
      blocks: unique(flatMap(this.blocks, block => block.getAdminViews()))
    });
  }

  getGqlAuxTypes(_ref7) {
    let {
      schemaName
    } = _ref7;
    return [...super.getGqlAuxTypes({
      schemaName
    }), ...this.auxList.getGqlTypes({
      schemaName
    })];
  }

  gqlAuxFieldResolvers(_ref8) {
    let {
      schemaName
    } = _ref8;
    return this.auxList.gqlFieldResolvers({
      schemaName
    });
  }

}

class MongoContentInterface extends Relationship.adapters.mongoose {}

class KnexContentInterface extends Relationship.adapters.knex {}

const Content$1 = {
  type: 'Content',
  implementation: Content,
  views: {
    Controller: _join(__dirname, "1kt0g8f"),
    Field: _join(__dirname, "11z4har"),
    Cell: _join(__dirname, "7nssg1"),
    Filter: Text.views.Filter
  },
  adapters: {
    mongoose: MongoContentInterface,
    knex: KnexContentInterface
  },
  blocks: {
    blockquote: BlockquoteBlock,
    heading: HeadingBlock,
    image: ImageContainerBlock,
    link: LinkBlock,
    orderedList: OrderedListBlock,
    unorderedList: UnorderedListBlock // not exposing list-item since it's only used internally by the other blocks
    // not exposing paragraph since it's included by default

  }
};
export { Content$1 as Content };
