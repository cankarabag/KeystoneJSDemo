import '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import _extends from '@babel/runtime/helpers/esm/extends';
import { LinkExternalIcon, LinkIcon, CheckIcon, CircleSlashIcon } from '@arch-ui/icons';
import { gridSize, colors } from '@arch-ui/theme';
import '@arch-ui/color-utils';
import '@arch-ui/tooltip';
import '@arch-ui/typography';
import { T as ToolbarButton } from './toolbar-components-f779486c.esm.js';
import React__default, { useState, useEffect, Fragment, useContext } from 'react';
import { Popper } from 'react-popper';
import { createPortal } from 'react-dom';
let type = 'link';

function Node(_ref) {
  let {
    node,
    attributes,
    children,
    isSelected,
    editor
  } = _ref;
  let {
    data
  } = node;
  const href = data.get('href');
  let [aElement, setAElement] = useState(null);
  let [linkInputValue, setLinkInputValue] = useState(href); // this is terrible
  // but probably necessary
  // because if we just do editor.setNodeByKey in the input onChange
  // and let that change propagate the cursor position breaks

  useEffect(() => {
    setLinkInputValue(href);
  }, [href]);
  return jsx(Fragment, null, jsx("a", _extends({}, attributes, {
    ref: setAElement,
    css: {
      color: 'blue',
      ':visited': {
        color: 'purple'
      }
    },
    href: href
  }), children), isSelected && createPortal(jsx(Popper, {
    placement: "bottom",
    referenceElement: aElement
  }, _ref2 => {
    let {
      style,
      ref
    } = _ref2;
    return jsx("div", {
      style: style,
      css: {
        margin: gridSize,
        display: 'flex'
      }
    }, jsx("div", {
      ref: ref,
      css: {
        backgroundColor: colors.N90,
        color: 'white',
        padding: 8,
        borderRadius: 6,
        display: 'flex'
      }
    }, jsx(LinkInput, {
      value: linkInputValue,
      onChange: event => {
        setLinkInputValue(event.target.value);
        editor.setNodeByKey(node.key, {
          data: data.set('href', event.target.value)
        });
      }
    }), jsx(ToolbarButton, {
      as: "a",
      tooltipPlacement: "bottom",
      icon: jsx(LinkExternalIcon, null),
      target: "_blank",
      rel: "noopener",
      label: "Open Link",
      css: {
        marginLeft: gridSize
      },
      href: href
    })));
  }), document.body));
}

function LinkInput(props) {
  return jsx("input", _extends({
    placeholder: "Link...",
    css: {
      border: 0,
      outline: 'none',
      background: 'transparent',
      color: 'white'
    }
  }, props));
}

let SetLinkRange = React__default.createContext(() => {});

let LinkMenu = props => {
  let [value, setValue] = useState('');
  return jsx("form", {
    onSubmit: e => {
      e.stopPropagation();
      e.preventDefault();
      props.onSubmit(value);
    },
    css: {
      display: 'flex'
    }
  }, jsx(LinkInput, {
    autoFocus: true,
    value: value,
    onChange: e => {
      setValue(e.target.value);
    }
  }), jsx(ToolbarButton, {
    label: "Submit",
    icon: jsx(CheckIcon, null),
    type: "submit"
  }), jsx(ToolbarButton, {
    label: "Cancel",
    icon: jsx(CircleSlashIcon, null),
    onClick: () => {
      props.onCancel();
    }
  }));
};

function Toolbar(_ref3) {
  let {
    children,
    editor
  } = _ref3;
  let [linkRange, setLinkRange] = useState(null);
  return jsx(SetLinkRange.Provider, {
    value: setLinkRange
  }, linkRange === null ? children : jsx(LinkMenu, {
    onSubmit: value => {
      editor.wrapInlineAtRange(linkRange, {
        type: type,
        data: {
          href: value
        }
      });
      editor.deselect();
    },
    onCancel: () => {
      setLinkRange(null);
    }
  }));
}

function ToolbarElement(_ref4) {
  let {
    editor,
    editorState
  } = _ref4;
  let hasLinks = editorState.inlines.some(inline => inline.type === type);
  let setLinkRange = useContext(SetLinkRange);
  return jsx(ToolbarButton, {
    isActive: hasLinks,
    label: hasLinks ? 'Remove Link' : 'Link',
    icon: jsx(LinkIcon, null),
    onClick: () => {
      if (hasLinks) {
        editor.unwrapInline(type);
      } else {
        setLinkRange(editorState.selection);
      }
    }
  });
}

export { Node, Toolbar, ToolbarElement, type };
