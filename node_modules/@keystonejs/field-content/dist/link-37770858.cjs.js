'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

require("@babel/runtime/helpers/objectWithoutProperties");

var core = require('@emotion/core');

var _extends = _interopDefault(require("@babel/runtime/helpers/extends"));

var icons = require('@arch-ui/icons');

var theme = require('@arch-ui/theme');

require('@arch-ui/color-utils');

require('@arch-ui/tooltip');

require('@arch-ui/typography');

var toolbarComponents = require('./toolbar-components-f0fc99c4.cjs.js');

var React = require('react');

var React__default = _interopDefault(React);

var reactPopper = require('react-popper');

var reactDom = require('react-dom');

let type = 'link';

function Node(_ref) {
  let {
    node,
    attributes,
    children,
    isSelected,
    editor
  } = _ref;
  let {
    data
  } = node;
  const href = data.get('href');
  let [aElement, setAElement] = React.useState(null);
  let [linkInputValue, setLinkInputValue] = React.useState(href); // this is terrible
  // but probably necessary
  // because if we just do editor.setNodeByKey in the input onChange
  // and let that change propagate the cursor position breaks

  React.useEffect(() => {
    setLinkInputValue(href);
  }, [href]);
  return core.jsx(React.Fragment, null, core.jsx("a", _extends({}, attributes, {
    ref: setAElement,
    css: {
      color: 'blue',
      ':visited': {
        color: 'purple'
      }
    },
    href: href
  }), children), isSelected && reactDom.createPortal(core.jsx(reactPopper.Popper, {
    placement: "bottom",
    referenceElement: aElement
  }, _ref2 => {
    let {
      style,
      ref
    } = _ref2;
    return core.jsx("div", {
      style: style,
      css: {
        margin: theme.gridSize,
        display: 'flex'
      }
    }, core.jsx("div", {
      ref: ref,
      css: {
        backgroundColor: theme.colors.N90,
        color: 'white',
        padding: 8,
        borderRadius: 6,
        display: 'flex'
      }
    }, core.jsx(LinkInput, {
      value: linkInputValue,
      onChange: event => {
        setLinkInputValue(event.target.value);
        editor.setNodeByKey(node.key, {
          data: data.set('href', event.target.value)
        });
      }
    }), core.jsx(toolbarComponents.ToolbarButton, {
      as: "a",
      tooltipPlacement: "bottom",
      icon: core.jsx(icons.LinkExternalIcon, null),
      target: "_blank",
      rel: "noopener",
      label: "Open Link",
      css: {
        marginLeft: theme.gridSize
      },
      href: href
    })));
  }), document.body));
}

function LinkInput(props) {
  return core.jsx("input", _extends({
    placeholder: "Link...",
    css: {
      border: 0,
      outline: 'none',
      background: 'transparent',
      color: 'white'
    }
  }, props));
}

let SetLinkRange = React__default.createContext(() => {});

let LinkMenu = props => {
  let [value, setValue] = React.useState('');
  return core.jsx("form", {
    onSubmit: e => {
      e.stopPropagation();
      e.preventDefault();
      props.onSubmit(value);
    },
    css: {
      display: 'flex'
    }
  }, core.jsx(LinkInput, {
    autoFocus: true,
    value: value,
    onChange: e => {
      setValue(e.target.value);
    }
  }), core.jsx(toolbarComponents.ToolbarButton, {
    label: "Submit",
    icon: core.jsx(icons.CheckIcon, null),
    type: "submit"
  }), core.jsx(toolbarComponents.ToolbarButton, {
    label: "Cancel",
    icon: core.jsx(icons.CircleSlashIcon, null),
    onClick: () => {
      props.onCancel();
    }
  }));
};

function Toolbar(_ref3) {
  let {
    children,
    editor
  } = _ref3;
  let [linkRange, setLinkRange] = React.useState(null);
  return core.jsx(SetLinkRange.Provider, {
    value: setLinkRange
  }, linkRange === null ? children : core.jsx(LinkMenu, {
    onSubmit: value => {
      editor.wrapInlineAtRange(linkRange, {
        type: type,
        data: {
          href: value
        }
      });
      editor.deselect();
    },
    onCancel: () => {
      setLinkRange(null);
    }
  }));
}

function ToolbarElement(_ref4) {
  let {
    editor,
    editorState
  } = _ref4;
  let hasLinks = editorState.inlines.some(inline => inline.type === type);
  let setLinkRange = React.useContext(SetLinkRange);
  return core.jsx(toolbarComponents.ToolbarButton, {
    isActive: hasLinks,
    label: hasLinks ? 'Remove Link' : 'Link',
    icon: core.jsx(icons.LinkIcon, null),
    onClick: () => {
      if (hasLinks) {
        editor.unwrapInline(type);
      } else {
        setLinkRange(editorState.selection);
      }
    }
  });
}

exports.Node = Node;
exports.Toolbar = Toolbar;
exports.ToolbarElement = ToolbarElement;
exports.type = type;
