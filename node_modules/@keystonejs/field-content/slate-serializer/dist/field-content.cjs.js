'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty"));

require('@keystonejs/utils');

var slateWalker = require('../../dist/slate-walker-18d20c31.cjs.js');

var slate = require('slate');

var assert = _interopDefault(require('nanoassert'));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
} // calling .toJSON() on all child nodes.


function shallowNodeToJson(node) {
  if (node.nodes) {
    return node.set('nodes', slate.Node.createList()).toJSON();
  }

  return node.toJSON();
}
/**
 * A normalized & serialized version of a Slate.js Node
 * @typedef {Object} SerializedNode
 * @property {Object} mutations KS5 GraphQL nested mutations, the IDs of which
 * will be stored in a `data._joinIds` array.
 * @property {Object} node A JSON representation of a Slate.js Node with
 * mutation data removed.
 */

/**
 * Convert a Slate.js Node into a JSON representation while extracting out any
 * GraphQL mutations which can be executed by the Keystone API.
 * @callback serialize
 * @param {Object} input
 * @param {Object} input.value A Slate.js Value
 * @param {Object} input.node A Slate.js Node
 * @return {SerializedNode}
 */

/**
 * @callback deserialize
 * @param {Object} input
 * @param {Object} input.node A Slate.js Node which will have a `data._joins`
 * array containing values that are IDs in the `input.joins` array
 * @param {Object[]} input.joins Array of joins data as plucked from
 * deserialize()
 * @return {Object} A Slate.js Node
 */

/**
 * @typedef {Object} Block
 * @property {String} type The unique type this block is for
 * @property {String} path The path into the data to lookup joined values
 * @property {serialize} serialize
 * @property {deserialize} deserialize
 */

/**
 * @param value Object A Slate.js Value. For example:
 * {
 *   document: [
 *     { object: 'block', type: 'cloudinaryImage', data: { file: <FileObject>, align: 'center' } },
 *     { object: 'block', type: 'cloudinaryImage', data: { file: <FileObject>, align: 'center' } },
 *     { object: 'block', type: 'relationshipTag', data: { name: 'foobar' } }
 *     { object: 'block', type: 'relationshipUser', data: { _joinIds: ['xyz789'], id: 'uoi678' } }
 *   ]
 * }
 * @param {Object.<string, Block>} blocks Blocks keyed by their type
 *
 * @return Object For example:
 * {
 *   document: [
 *     { object: 'block', type: 'cloudinaryImage', data: { _mutationPath: 'cloudinaryImages.create[0]' } },
 *     { object: 'block', type: 'cloudinaryImage', data: { _mutationPath: 'cloudinaryImages.create[1]' } },
 *     { object: 'block', type: 'relationshipTag', data: { _mutationPath: 'relationshipTags.create[0]' } }
 *     { object: 'block', type: 'relationshipUser', data: { _mutationPath: 'relationshipUsers.connect[0]' } }
 *   ],
 *   cloudinaryImages: {
 *     create: [
 *       { image: <FileObject>, align: 'center' },
 *       { image: <FileObject>, align: 'center' },
 *     ]
 *   },
 *   relationshipTags: {
 *     create: [{ tag: { create: { name: 'foobar' } } }],
 *   },
 *   relationshipUsers: {
 *     connect: [{ id: 'xyz789' }],
 *   },
 * }
 */


function serialize(value, blocks) {
  const allMutations = {};
  const serializedDocument = slateWalker.walkSlateNode(value.document, {
    visitBlock(node) {
      const block = blocks[node.type]; // No matching block that we're in charge of

      if (!block || typeof block.serialize !== 'function') {
        return;
      }

      const {
        mutations,
        node: serializedNode
      } = block.serialize({
        value,
        node,
        blocks
      });

      if (mutations && Object.keys(mutations).length) {
        if (!serializedNode) {
          throw new Error("Must return a serialized 'node' when returning 'mutations'. See '".concat(block.constructor.name, "#serialize()'."));
        }

        if (!block.path) {
          throw new Error("No mutation path set for block view type '".concat(block.type, "'. Ensure the block's view exports a 'path' key corresponding to the mutation path for saving block data"));
        } // Ensure the mutation group exists


        allMutations[block.path] = allMutations[block.path] || {
          // TODO: Don't forcible disconnect & reconnect. (It works because we know
          // the entire document, so all creations & connections exist below).
          // Really, we should do a diff and only perform the things that have
          // actually changed. Although, this may be quite complex.
          disconnectAll: true
        }; // Ensure there's a .data._mutationPaths array

        serializedNode.data = serializedNode.data || {};
        serializedNode.data._mutationPaths = serializedNode.data._mutationPaths || []; // Gather up all the mutations, keyed by the block's path & the
        // "action" returned by the serialize call.

        Object.entries(mutations).forEach(_ref => {
          let [action, mutationData] = _ref;
          allMutations[block.path][action] = allMutations[block.path][action] || [];
          mutationData = Array.isArray(mutationData) ? mutationData : [mutationData];
          mutationData.forEach(mutation => {
            const insertedBefore = allMutations[block.path][action].push(mutation);
            const mutationPath = "".concat(block.path, ".").concat(action, "[").concat(insertedBefore - 1, "]");

            serializedNode.data._mutationPaths.push(mutationPath);
          });
        });
      }

      return serializedNode ? serializedNode : null;
    },

    // Everything we don't handle, we turn into JSON, but still visit all
    // the child nodes.
    defaultVisitor(node, visitNode) {
      // visit this node first
      const visitedNode = shallowNodeToJson(node);

      if (node.nodes) {
        // Now we recurse into the child nodes array
        visitedNode.nodes = node.nodes.map(childNode => visitNode(childNode)).toJSON();
      }

      return visitedNode;
    }

  });
  return _objectSpread({
    document: serializedDocument
  }, allMutations);
}
/**
 * @param {Object} data Object For example:
 * {
 *   document: [
 *     { object: 'block', type: 'cloudinaryImage', data: { _joinIds: ['abc123'] } },
 *     { object: 'block', type: 'cloudinaryImage', data: { _joinIds: ['qwe345'] } },
 *     { object: 'block', type: 'relationshipUser', data: { _joinIds: ['ert567'] } }
 *     { object: 'block', type: 'relationshipUser', data: { _joinIds: ['xyz890'] } }
 *   ],
 *   cloudinaryImages: [
 *     { id: 'abc123', publicUrl: '...', align: 'center' },
 *     { id: 'qwe345', publicUrl: '...', align: 'center' },
 *   ],
 *   relationshipUsers: [
 *     { id: 'ert567', user: { id: 'dfg789' } },
 *     { id: 'xyz890', user: { id: 'uoi678' } },
 *   ],
 * }
 * @param {Object.<string, Block>} blocks Blocks keyed by their type
 *
 * @return Object A Slate.js Document with all the _joinIds data inlined into
 * the appropriate blocks
 */


function deserialize(_ref2, blocks) {
  let {
    document
  } = _ref2,
      serializations = _objectWithoutProperties(_ref2, ["document"]);

  assert(!!document, 'Must pass document to deserialize()');
  assert(!!blocks, 'Must pass blocks to deserialize()');
  const value = slate.Value.fromJSON({
    document
  });
  return value.set('document', slateWalker.walkSlateNode(value.document, {
    visitBlock(node) {
      const block = blocks[node.type]; // No matching block that we're in charge of

      if (!block || typeof block.deserialize !== 'function') {
        return;
      } // Pick out the data set based on the block's path


      const data = serializations[block.path];
      const nodeData = node.get('data');
      const joins = (nodeData && nodeData.size && nodeData.get('_joinIds') || []).map(joinId => data.find(_ref3 => {
        let {
          id
        } = _ref3;
        return joinId === id;
      })); // NOTE: deserialize _may_ return null. It will then fall into the
      // `defaultVisitor` handler below.

      const newNode = block.deserialize({
        node,
        joins,
        blocks
      }); // Returning falsey will fall through to the default visitor below

      if (!newNode) {
        return;
      }

      if (!slate.Node.isNode(newNode)) {
        throw new Error("".concat(block.constructor.name, "#deserialize() must return a Slate.js Node."));
      }

      return newNode;
    },

    defaultVisitor(node, visitNode) {
      if (node.nodes) {
        // Now we recurse into the child nodes array
        // NOTE: The result is immutable, so we have to return the result of
        // `.set` here.
        return node.set('nodes', node.nodes.map(visitNode));
      }

      return node;
    }

  }));
}

exports.deserialize = deserialize;
exports.serialize = serialize;
