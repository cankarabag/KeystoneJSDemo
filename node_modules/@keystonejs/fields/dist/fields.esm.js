import { join as _join } from "path";
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import inflection from 'inflection';
import { parseFieldAccess } from '@keystonejs/access-control';
import parse from 'date-fns/parse';
import format from 'date-fns/format';
import { MongooseFieldAdapter } from '@keystonejs/adapter-mongoose';
import { KnexFieldAdapter } from '@keystonejs/adapter-knex';
import mongoose from 'mongoose';
import pluralize from 'pluralize';
import { Block } from '@keystonejs/field-content/Block';
import { imageContainer, caption } from '@keystonejs/field-content/blocks';
import groupBy from 'lodash.groupby';
import pSettle from 'p-settle';
import { pick, intersection } from '@keystonejs/utils';
import { createError } from 'apollo-errors';
import { GraphQLScalarType } from 'graphql';
import { Kind } from 'graphql/language';
import { DateTime, FixedOffsetZone } from 'luxon';
import fetch from 'node-fetch';
import { q as queryFragment } from './query-fragment-3475495f.esm.js';
import bcrypt from 'bcrypt';
import dumbPasswords from 'dumb-passwords';
import slugify from '@sindresorhus/slugify';
import cuid from 'cuid';
import UnsplashAPI, { toJson } from 'unsplash-js';
import queryString from 'query-string';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Field {
  constructor(path, _ref, _ref2) {
    let {
      getListByKey,
      listKey,
      listAdapter,
      fieldAdapterClass,
      defaultAccess,
      schemaNames
    } = _ref2;

    let {
      hooks = {},
      isRequired,
      defaultValue,
      access,
      label,
      schemaDoc,
      adminDoc
    } = _ref,
        config = _objectWithoutProperties(_ref, ["hooks", "isRequired", "defaultValue", "access", "label", "schemaDoc", "adminDoc"]);

    this.path = path;
    this.isPrimaryKey = path === 'id';
    this.schemaDoc = schemaDoc;
    this.adminDoc = adminDoc;
    this.config = config;
    this.isRequired = !!isRequired;
    this.defaultValue = defaultValue;
    this.isOrderable = false;
    this.hooks = hooks;
    this.getListByKey = getListByKey;
    this.listKey = listKey;
    this.label = label || inflection.humanize(inflection.underscore(path));
    this.adapter = listAdapter.newFieldAdapter(fieldAdapterClass, this.constructor.name, path, this, getListByKey, _objectSpread({}, config)); // Should be overwritten by types that implement a Relationship interface

    this.isRelationship = false;
    this.access = this.parseFieldAccess({
      schemaNames,
      listKey,
      fieldKey: path,
      defaultAccess,
      access
    });
  }

  parseFieldAccess(args) {
    return parseFieldAccess(args);
  } // Field types should replace this if they want to any fields to the output type


  gqlOutputFields() {
    return [];
  }

  gqlOutputFieldResolvers() {
    return {};
  }
  /**
   * Auxiliary Types are top-level types which a type may need or provide.
   * Example: the `File` type, adds a graphql auxiliary type of `FileUpload`, as
   * well as an `uploadFile()` graphql auxiliary type query resolver
   *
   * These are special cases, and should be used sparingly
   *
   * NOTE: When a naming conflic occurs, a list's types/queries/mutations will
   * overwrite any auxiliary types defined by an individual type.
   */


  getGqlAuxTypes() {
    return [];
  }

  gqlAuxFieldResolvers() {
    return {};
  }

  getGqlAuxQueries() {
    return [];
  }

  gqlAuxQueryResolvers() {
    return {};
  }

  getGqlAuxMutations() {
    return [];
  }

  gqlAuxMutationResolvers() {
    return {};
  }
  /*
   * @param {Object} data
   * @param {Object} data.resolvedData  The incoming item for the mutation with
   * relationships and defaults already resolved
   * @param {Object} data.existingItem If this is a updateX mutation, this will
   * be the existing data in the database
   * @param {Object} data.context The graphQL context object of the current
   * request
   * @param {Object} data.originalInput The raw incoming item from the mutation
   * (no relationships or defaults resolved)
   * @param {Object} data.actions
   * @param {Function} data.actions.query Perform a graphQl query
   * programatically
   */


  async resolveInput(_ref3) {
    let {
      resolvedData
    } = _ref3;
    return resolvedData[this.path];
  }

  async validateInput() {}

  async beforeChange() {}

  async afterChange() {}

  async beforeDelete() {}

  async validateDelete() {}

  async afterDelete() {}

  gqlQueryInputFields() {
    return [];
  }

  equalityInputFields(type) {
    return ["".concat(this.path, ": ").concat(type), "".concat(this.path, "_not: ").concat(type)];
  }

  equalityInputFieldsInsensitive(type) {
    return ["".concat(this.path, "_i: ").concat(type), "".concat(this.path, "_not_i: ").concat(type)];
  }

  inInputFields(type) {
    return ["".concat(this.path, "_in: [").concat(type, "]"), "".concat(this.path, "_not_in: [").concat(type, "]")];
  }

  orderingInputFields(type) {
    return ["".concat(this.path, "_lt: ").concat(type), "".concat(this.path, "_lte: ").concat(type), "".concat(this.path, "_gt: ").concat(type), "".concat(this.path, "_gte: ").concat(type)];
  }

  stringInputFields(type) {
    return ["".concat(this.path, "_contains: ").concat(type), "".concat(this.path, "_not_contains: ").concat(type), "".concat(this.path, "_starts_with: ").concat(type), "".concat(this.path, "_not_starts_with: ").concat(type), "".concat(this.path, "_ends_with: ").concat(type), "".concat(this.path, "_not_ends_with: ").concat(type)];
  }

  stringInputFieldsInsensitive(type) {
    return ["".concat(this.path, "_contains_i: ").concat(type), "".concat(this.path, "_not_contains_i: ").concat(type), "".concat(this.path, "_starts_with_i: ").concat(type), "".concat(this.path, "_not_starts_with_i: ").concat(type), "".concat(this.path, "_ends_with_i: ").concat(type), "".concat(this.path, "_not_ends_with_i: ").concat(type)];
  }

  get gqlCreateInputFields() {
    return [];
  }

  get gqlUpdateInputFields() {
    return [];
  }

  getAdminMeta(_ref4) {
    let {
      schemaName
    } = _ref4;
    const schemaAccess = this.access[schemaName];
    return this.extendAdminMeta({
      label: this.label,
      path: this.path,
      type: this.constructor.name,
      isRequired: this.isRequired,
      isOrderable: this.isOrderable,
      // We can only pass scalar default values through to the admin ui, not
      // functions
      defaultValue: typeof this.defaultValue !== 'function' ? this.defaultValue : undefined,
      isPrimaryKey: this.isPrimaryKey,
      // NOTE: This data is serialised, so we're unable to pass through any
      // access control _functions_. But we can still check for the boolean case
      // and pass that through (we assume that if there is a function, it's a
      // "maybe" true, so default it to true).
      access: {
        create: !!schemaAccess.create,
        read: !!schemaAccess.read,
        update: !!schemaAccess.update
      },
      adminDoc: this.adminDoc
    });
  }

  extendAdminMeta(meta) {
    return meta;
  }

  extendAdminViews(views) {
    return views;
  }

  getDefaultValue(_ref5) {
    let {
      existingItem,
      context,
      originalInput,
      actions
    } = _ref5;

    if (typeof this.defaultValue !== 'undefined') {
      if (typeof this.defaultValue === 'function') {
        return this.defaultValue({
          existingItem,
          context,
          originalInput,
          actions
        });
      } else {
        return this.defaultValue;
      }
    } // By default, the default value is undefined


    return undefined;
  }

}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class CalendarDay extends Field {
  constructor(path, _ref) {
    let {
      format = 'YYYY-MM-DD',
      yearRangeFrom = new Date().getFullYear() - 100,
      yearRangeTo = new Date().getFullYear()
    } = _ref;
    super(...arguments);
    this.format = format;
    this.yearRangeFrom = yearRangeFrom;
    this.yearRangeTo = yearRangeTo;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": String")];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.orderingInputFields('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  extendAdminMeta(meta) {
    return _objectSpread$1({}, meta, {
      format: this.format,
      yearRangeFrom: this.yearRangeFrom,
      yearRangeTo: this.yearRangeTo
    });
  }

}

const CommonCalendarInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$1({}, this.equalityConditions(dbPath), {}, this.orderingConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoCalendarDayInterface extends CommonCalendarInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const validator = a => typeof a === 'string' && format(parse(a), 'YYYY-MM-DD') === a;

    const schemaOptions = {
      type: String,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not an ISO8601 date string (YYYY-MM-DD)'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexCalendarDayInterface extends CommonCalendarInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.date(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

  setupHooks(_ref2) {
    let {
      addPostReadHook
    } = _ref2;
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = format(item[this.path], 'YYYY-MM-DD');
      }

      return item;
    });
  }

}

var index = {
  type: 'CalendarDay',
  implementation: CalendarDay,
  views: {
    Controller: _join(__dirname, "lyydfj"),
    Field: _join(__dirname, "ylvj83"),
    Filter: _join(__dirname, "153uqzr"),
    Cell: _join(__dirname, "g59l7t")
  },
  adapters: {
    mongoose: MongoCalendarDayInterface,
    knex: KnexCalendarDayInterface
  }
};

class Checkbox extends Field {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": Boolean")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return this.equalityInputFields('Boolean');
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": Boolean")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": Boolean")];
  }

}

class MongoCheckboxInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Boolean
      }, this.config)
    });
  }

  getQueryConditions(dbPath) {
    return this.equalityConditions(dbPath);
  }

}

class KnexCheckboxInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config

    if (this.config.isUnique || this.config.isIndexed) {
      throw "The Checkbox field type doesn't support indexes on Knex. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }
  }

  addToTableSchema(table) {
    const column = table.boolean(this.path);
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

  getQueryConditions(dbPath) {
    return this.equalityConditions(dbPath);
  }

}

var index$1 = {
  type: 'Checkbox',
  implementation: Checkbox,
  views: {
    Controller: _join(__dirname, "rklrac"),
    Field: _join(__dirname, "ore4pa"),
    Filter: _join(__dirname, "nh8nsp"),
    Cell: _join(__dirname, "1v516tp")
  },
  adapters: {
    mongoose: MongoCheckboxInterface,
    knex: KnexCheckboxInterface
  }
};

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
} // https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md#checking-if-a-path-is-populated


mongoose.set('objectIdGetter', false);
const {
  Types: {
    ObjectId
  }
} = mongoose;

class File extends Field {
  constructor(path, _ref) {
    let {
      directory,
      route,
      adapter
    } = _ref;
    super(...arguments);
    this.graphQLOutputType = 'File';
    this.directory = directory;
    this.route = route;
    this.fileAdapter = adapter;

    if (!this.fileAdapter) {
      throw new Error("No file adapter provided for File field.");
    }
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.graphQLOutputType)];
  }

  extendAdminMeta(meta) {
    return _objectSpread$2({}, meta, {
      directory: this.directory,
      route: this.route
    });
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getFileUploadType() {
    return 'Upload';
  }

  getGqlAuxTypes() {
    return ["\n      type ".concat(this.graphQLOutputType, " {\n        id: ID\n        path: String\n        filename: String\n        originalFilename: String\n        mimetype: String\n        encoding: String\n        publicUrl: String\n      }\n    ")];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        } // FIXME: This can hopefully be removed once graphql 14.1.0 is released.
        // https://github.com/graphql/graphql-js/pull/1520


        if (itemValues.id) itemValues.id = itemValues.id.toString();
        return _objectSpread$2({
          publicUrl: this.fileAdapter.publicUrl(itemValues)
        }, itemValues);
      }
    };
  }

  async resolveInput(_ref2) {
    let {
      resolvedData,
      existingItem
    } = _ref2;
    const previousData = existingItem && existingItem[this.path];
    const uploadData = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!uploadData) return uploadData`, but that would lose the
    // nuance of returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof uploadData === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (uploadData === null) {
      // `null` was specifically uploaded, and we should set the field value to
      // null. To do that we... return `null`
      return null;
    }

    const {
      createReadStream,
      filename: originalFilename,
      mimetype,
      encoding
    } = await uploadData;
    const stream = createReadStream();

    if (!stream && previousData) {
      // TODO: FIXME: Handle when stream is null. Can happen when:
      // Updating some other part of the item, but not the file (gets null
      // because no File DOM element is uploaded)
      return previousData;
    }

    const newId = new ObjectId();
    const {
      id,
      filename,
      _meta
    } = await this.fileAdapter.save({
      stream,
      filename: originalFilename,
      mimetype,
      encoding,
      id: newId
    });
    return {
      id,
      filename,
      originalFilename,
      mimetype,
      encoding,
      _meta
    };
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": ").concat(this.getFileUploadType())];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": ").concat(this.getFileUploadType())];
  }

}

const CommonFileInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$2({}, this.equalityConditions(dbPath), {}, this.stringConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoFileInterface extends CommonFileInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: {
        id: ObjectId,
        path: String,
        filename: String,
        mimetype: String,
        _meta: Object
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexFileInterface extends CommonFileInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw "The File field type doesn't support indexes on Knex. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class CloudinaryImage extends File {
  constructor() {
    super(...arguments);
    this.graphQLOutputType = 'CloudinaryImage_File';
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.graphQLOutputType)];
  }

  extendAdminMeta(meta) {
    // Overwrite so we have only the original meta
    return meta;
  }

  getFileUploadType() {
    return 'Upload';
  }

  getGqlAuxTypes(_ref) {
    let {
      schemaName
    } = _ref;
    return [...super.getGqlAuxTypes({
      schemaName
    }), "\n      \"\"\"Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).\n      All options are strings as they ultimately end up in a URL.\"\"\"\n      input CloudinaryImageFormat {\n        # Rewrites the filename to be this pretty string. Do not include '/' or '.'\n        prettyName: String\n        width: String\n        height: String\n        crop: String\n        aspect_ratio: String\n        gravity: String\n        zoom: String\n        x: String\n        y: String\n        format: String\n        fetch_format: String\n        quality: String\n        radius: String\n        angle: String\n        effect: String\n        opacity: String\n        border: String\n        background: String\n        overlay: String\n        underlay: String\n        default_image: String\n        delay: String\n        color: String\n        color_space: String\n        dpr: String\n        page: String\n        density: String\n        flags: String\n        transformation: String\n      }", "extend type ".concat(this.graphQLOutputType, " {\n        publicUrlTransformed(transformation: CloudinaryImageFormat): String\n      }")];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        } // FIXME: This can hopefully be removed once graphql 14.1.0 is released.
        // https://github.com/graphql/graphql-js/pull/1520


        if (itemValues.id) itemValues.id = itemValues.id.toString();
        return _objectSpread$3({
          publicUrl: this.fileAdapter.publicUrl(itemValues),
          publicUrlTransformed: _ref2 => {
            let {
              transformation
            } = _ref2;
            return this.fileAdapter.publicUrlTransformed(itemValues, transformation);
          }
        }, itemValues);
      }
    };
  }

}

function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function initOptions(options) {
  let optionsArray = options;
  if (typeof options === 'string') optionsArray = options.split(/\,\s*/);
  if (!Array.isArray(optionsArray)) return null;
  return optionsArray.map(i => {
    return typeof i === 'string' ? {
      value: i,
      label: inflection.humanize(i)
    } : i;
  });
}

class Select extends Field {
  constructor(path, _ref) {
    let {
      options
    } = _ref;
    super(...arguments);
    this.options = initOptions(options);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.getTypeName())];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  getTypeName() {
    return "".concat(this.listKey).concat(inflection.classify(this.path), "Type");
  }

  getGqlAuxTypes() {
    // TODO: I'm really not sure it's safe to generate GraphQL Enums from
    // whatever options people provide, this could easily break with spaces and
    // special characters in values so may not be worth it...
    return ["\n      enum ".concat(this.getTypeName(), " {\n        ").concat(this.options.map(i => i.value).join('\n        '), "\n      }\n    ")];
  }

  extendAdminMeta(meta) {
    return _objectSpread$4({}, meta, {
      options: this.options
    });
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields(this.getTypeName()), ...this.inInputFields(this.getTypeName())];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": ").concat(this.getTypeName())];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": ").concat(this.getTypeName())];
  }

}

const CommonSelectInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$4({}, this.equalityConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoSelectInterface extends CommonSelectInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }

}

class KnexSelectInterface extends CommonSelectInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.enu(this.path, this.field.options.map(_ref2 => {
      let {
        value
      } = _ref2;
      return value;
    }));
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var SelectType = {
  type: 'Select',
  implementation: Select,
  views: {
    Controller: _join(__dirname, "agsrum"),
    Field: _join(__dirname, "s67gr7"),
    Filter: _join(__dirname, "mtwbac"),
    Cell: _join(__dirname, "1u1co9j")
  },
  adapters: {
    mongoose: MongoSelectInterface,
    knex: KnexSelectInterface
  }
};
const ParameterError = createError('ParameterError', {
  message: 'Incorrect parameters supplied',
  options: {
    showPath: true
  }
});

function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const NESTED_MUTATIONS = ['create', 'connect', 'disconnect', 'disconnectAll'];
/*** Input validation  ***/

const throwWithErrors = (message, meta) => {
  const error = new Error(message);
  throw Object.assign(error, meta);
};

function validateInput(_ref) {
  let {
    input,
    target,
    many
  } = _ref; // Only accept mutations which we know how to handle.

  let validInputMutations = intersection(Object.keys(input), NESTED_MUTATIONS); // Filter out mutations which don't have any parameters

  if (many) {
    // to-many must have an array of objects
    validInputMutations = validInputMutations.filter(mutation => mutation === 'disconnectAll' || Array.isArray(input[mutation]));
  } else {
    validInputMutations = validInputMutations.filter(mutation => mutation === 'disconnectAll' || Object.keys(input[mutation]).length);
  } // We must have at least one valid mutation


  if (!validInputMutations.length) {
    throw new ParameterError({
      message: "Must provide a nested mutation (".concat(NESTED_MUTATIONS.join(', '), ") when mutating ").concat(target)
    });
  } // For a non-many relationship we can't create AND connect - only one can be set at a time


  if (!many && validInputMutations.includes('create') && validInputMutations.includes('connect')) {
    throw new ParameterError({
      message: "Can only provide one of 'connect' or 'create' when mutating ".concat(target)
    });
  }

  return validInputMutations;
}

const cleanAndValidateInput = _ref2 => {
  let {
    input,
    many,
    localField,
    target
  } = _ref2;

  try {
    return pick(input, validateInput({
      input,
      target,
      many
    }));
  } catch (error) {
    const message = "Nested mutation operation invalid for ".concat(target);
    error.path = ['<validate>'];
    throwWithErrors(message, {
      errors: [error],
      path: [localField.path]
    });
  }
};

const _runActions = async (action, targets, path) => {
  const results = await pSettle((targets || []).map(action));
  const errors = results.map((settleInfo, index) => _objectSpread$5({}, settleInfo, {
    index
  })).filter(_ref3 => {
    let {
      isRejected
    } = _ref3;
    return isRejected;
  }).map(_ref4 => {
    let {
      reason,
      index
    } = _ref4;
    reason.path = [...path, index];
    return reason;
  }); // If there are no errors we know everything resolved successfully

  return [errors.length ? [] : results.map(_ref5 => {
    let {
      value
    } = _ref5;
    return value;
  }), errors];
};

async function resolveNestedMany(_ref6) {
  let {
    input,
    currentValue,
    refList,
    context,
    localField,
    target,
    mutationState
  } = _ref6; // Disconnections

  let disconnectIds = [];

  if (input.disconnectAll) {
    disconnectIds = [...currentValue];
  } else if (input.disconnect) {
    // We want to avoid DB lookups where possible, so we split the input into
    // two halves; one with ids, and the other without ids
    const {
      withId,
      withoutId
    } = groupBy(input.disconnect, _ref7 => {
      let {
        id
      } = _ref7;
      return id ? 'withId' : 'withoutId';
    }); // We set the Ids we do find immediately

    disconnectIds = (withId || []).map(_ref8 => {
      let {
        id
      } = _ref8;
      return id;
    }); // And any without ids (ie; other unique criteria), have to be looked up
    // This will resolve access control, etc for us.
    // In the future, when WhereUniqueInput accepts more than just an id,
    // this will also resolve those queries for us too.

    const action = where => refList.itemQuery(where, context, refList.gqlNames.itemQueryName); // We don't throw if any fail; we're only interested in the ones this user has
    // access to read (and hence remove from the list)


    const disconnectItems = (await pSettle((withoutId || []).map(action))).filter(_ref9 => {
      let {
        isFulfilled
      } = _ref9;
      return isFulfilled;
    }).map(_ref10 => {
      let {
        value
      } = _ref10;
      return value;
    }).filter(itemToDisconnect => itemToDisconnect); // Possible to get null results when the id doesn't exist, or read access is denied

    disconnectIds.push(...disconnectItems.map(_ref11 => {
      let {
        id
      } = _ref11;
      return id;
    }));
  } // Connections


  let connectedIds = [];
  let createdIds = [];

  if (input.connect || input.create) {
    // This will resolve access control, etc for us.
    // In the future, when WhereUniqueInput accepts more than just an id,
    // this will also resolve those queries for us too.
    const [connectedItems, connectErrors] = await _runActions(where => refList.itemQuery({
      where
    }, context, refList.gqlNames.itemQueryName), input.connect, ['connect']); // Create related item. Will check for access control itself, no need to do anything extra here.
    // NOTE: We don't check for read access control on the returned ids as the
    // user will not have seen it, so it's ok to return it directly here.

    const [createdItems, createErrors] = await _runActions(data => refList.createMutation(data, context, mutationState), input.create, ['create']);
    const allErrors = [...connectErrors, ...createErrors];

    if (allErrors.length) {
      const message = "Unable to create and/or connect ".concat(allErrors.length, " ").concat(target);
      throwWithErrors(message, {
        errors: allErrors,
        path: [localField.path]
      });
    }

    connectedIds = connectedItems.map(item => {
      if (item && item.id) {
        return item.id;
      } // Possible to get null results when the id doesn't exist, or read access is denied


      return null;
    });
    createdIds = createdItems.map(item => {
      if (item && item.id) {
        return item.id;
      } // Possible to get null results when the id doesn't exist, or read access is denied


      return null;
    });
  }

  return {
    disconnect: disconnectIds,
    connect: connectedIds,
    create: createdIds
  };
}

async function resolveNestedSingle(_ref12) {
  let {
    input,
    currentValue,
    localField,
    refList,
    context,
    target,
    mutationState
  } = _ref12;
  let result_ = {};

  if ((input.disconnect || input.disconnectAll) && currentValue) {
    let idToDisconnect;

    if (input.disconnectAll) {
      idToDisconnect = currentValue;
    } else if (input.disconnect.id) {
      idToDisconnect = input.disconnect.id;
    } else {
      try {
        // Support other unique fields for disconnection
        idToDisconnect = (await refList.itemQuery({
          where: input.disconnect
        }, context, refList.gqlNames.itemQueryName)).id.toString();
      } catch (error) {// Maybe we don't have read access, or maybe the item doesn't exist
        // (recently deleted, or it's an erroneous value in the relationship field)
        // So we silently ignore it
      }
    }

    if (currentValue === idToDisconnect) {
      // Found the item, so unset it
      result_.disconnect = [idToDisconnect];
    }
  }

  let operation;
  let method;

  if (input.connect) {
    operation = 'connect';

    method = () => refList.itemQuery({
      where: input.connect
    }, context, refList.gqlNames.itemQueryName);
  } else if (input.create) {
    operation = 'create';

    method = () => refList.createMutation(input.create, context, mutationState);
  }

  if (operation) {
    // override result with the connected/created value
    // input is of type *RelateToOneInput
    let item;

    try {
      item = await method();
    } catch (error) {
      const message = "Unable to ".concat(operation, " a ").concat(target);
      error.path = [operation];
      throwWithErrors(message, {
        errors: [error],
        path: [localField.path]
      });
    } // Might not exist if the input id doesn't exist / the user doesn't have read access


    if (item) {
      result_[operation] = [item.id];
    }
  }

  return result_;
}
/*
 * Resolve the nested mutations and return the ids of items to be connected/disconnected
 *
 * Returns: { connect: [id], disconnect: [id]}
 */


async function resolveNested(_ref13) {
  let {
    input,
    currentValue,
    many,
    listInfo,
    context,
    mutationState
  } = _ref13;
  const localList = listInfo.local.list;
  const localField = listInfo.local.field;
  const refList = listInfo.foreign.list;
  const target = "".concat(localList.key, ".").concat(localField.path, "<").concat(refList.key, ">");
  const args = {
    currentValue,
    refList,
    input: cleanAndValidateInput({
      input,
      many,
      localField,
      target
    }),
    context,
    localField,
    target,
    mutationState
  };
  return await (many ? resolveNestedMany(args) : resolveNestedSingle(args));
}

function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _queueIdForOperation(_ref) {
  let {
    queue,
    foreign,
    local,
    done
  } = _ref; // The queueID encodes the full list/field path and ID of both the foreign and local fields

  const f = info => "".concat(info.list.key, ".").concat(info.field.path, ".").concat(info.id);

  const queueId = "".concat(f(local), "->").concat(f(foreign)); // It may have already been added elsewhere, so we don't want to add it again

  if (!queue.has(queueId)) {
    queue.set(queueId, {
      local,
      foreign: {
        id: foreign.id
      },
      done
    });
  }
}

function enqueueBacklinkOperations(operations, queues, getItem, local, foreign) {
  Object.entries(operations).forEach(_ref2 => {
    let [operation, idsToOperateOn = []] = _ref2;
    queues[operation] = queues[operation] || new Map();
    const queue = queues[operation]; // NOTE: We don't return this promises, we expect it to be fulfilled at a
    // future date and don't want to wait for it now.

    getItem.then(item => {
      const _local = _objectSpread$6({}, local, {
        id: item.id
      });

      idsToOperateOn.forEach(id => {
        const _foreign = _objectSpread$6({}, foreign, {
          id
        }); // Enqueue the backlink operation (foreign -> local)


        _queueIdForOperation({
          queue,
          foreign: _local,
          local: _foreign,
          done: false
        }); // Effectively dequeue the forward link operation (local -> foreign)
        // To avoid any circular updates with the above disconnect, we flag this
        // item as having already been connected/disconnected


        _queueIdForOperation({
          queue,
          foreign: _foreign,
          local: _local,
          done: true
        });
      });
    });
  });
}

async function resolveBacklinks(context, mutationState) {
  await Promise.all(Object.entries(mutationState.queues).map(async _ref3 => {
    let [operation, queue] = _ref3;

    for (let queuedWork of queue.values()) {
      if (queuedWork.done) {
        continue;
      } // Flag it as handled so we don't try again in a nested update
      // NOTE: We do this first before any other work below to avoid async issues
      // To avoid issues with looping and Map()s, we directly set the value on the
      // object as stored in the Map, and don't try to update the Map() itself.


      queuedWork.done = true; // Run update of local.path <operation>>> foreign.id
      // NOTE: This relies on the user having `update` permissions on the local list.

      const {
        local,
        foreign
      } = queuedWork;
      const {
        path,
        many
      } = local.field;
      const clause = {
        [path]: {
          [operation]: many ? [foreign] : foreign
        }
      };
      await local.list.updateMutation(local.id.toString(), clause, context, mutationState);
    }
  }));
}

function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const {
  Schema: {
    Types: {
      ObjectId: ObjectId$1
    }
  }
} = mongoose;

class Relationship extends Field {
  constructor(path, _ref) {
    let {
      ref,
      many,
      withMeta
    } = _ref;
    super(...arguments); // JM: It bugs me this is duplicated in the field adapters but initialisation order makes it hard to avoid

    const [refListKey, refFieldPath] = ref.split('.');
    this.refListKey = refListKey;
    this.refFieldPath = refFieldPath;
    this.isOrderable = true;
    this.isRelationship = true;
    this.many = many;
    this.withMeta = typeof withMeta !== 'undefined' ? withMeta : true;
  }

  tryResolveRefList() {
    const {
      listKey,
      path,
      refListKey,
      refFieldPath
    } = this;
    const refList = this.getListByKey(refListKey);

    if (!refList) {
      throw new Error("Unable to resolve related list '".concat(refListKey, "' from ").concat(listKey, ".").concat(path));
    }

    let refField;

    if (refFieldPath) {
      refField = refList.getFieldByPath(refFieldPath);

      if (!refField) {
        throw new Error("Unable to resolve two way relationship field '".concat(refListKey, ".").concat(refFieldPath, "' from ").concat(listKey, ".").concat(path));
      }
    }

    return {
      refList,
      refField
    };
  }

  gqlOutputFields(_ref2) {
    let {
      schemaName
    } = _ref2;
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].read) {
      // It's not accessible in any way, so we can't expose the related field
      return [];
    }

    if (this.many) {
      const filterArgs = refList.getGraphqlFilterFragment().join('\n');
      return ["".concat(this.path, "(").concat(filterArgs, "): [").concat(refList.gqlNames.outputTypeName, "]"), this.withMeta ? "_".concat(this.path, "Meta(").concat(filterArgs, "): _QueryMeta") : ''];
    }

    return ["".concat(this.path, ": ").concat(refList.gqlNames.outputTypeName)];
  }

  extendAdminMeta(meta) {
    const {
      refListKey: ref,
      refFieldPath,
      many
    } = this;
    return _objectSpread$7({}, meta, {
      ref,
      refFieldPath,
      many
    });
  }

  gqlQueryInputFields(_ref3) {
    let {
      schemaName
    } = _ref3;
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].read) {
      // It's not accessible in any way, so we can't expose the related field
      return [];
    }

    if (this.many) {
      return ["\"\"\" condition must be true for all nodes \"\"\"\n        ".concat(this.path, "_every: ").concat(refList.gqlNames.whereInputName), "\"\"\" condition must be true for at least 1 node \"\"\"\n        ".concat(this.path, "_some: ").concat(refList.gqlNames.whereInputName), "\"\"\" condition must be false for all nodes \"\"\"\n        ".concat(this.path, "_none: ").concat(refList.gqlNames.whereInputName), "\"\"\" is the relation field null \"\"\"\n        ".concat(this.path, "_is_null: Boolean")];
    } else {
      return ["".concat(this.path, ": ").concat(refList.gqlNames.whereInputName), "".concat(this.path, "_is_null: Boolean")];
    }
  }

  gqlOutputFieldResolvers(_ref4) {
    let {
      schemaName
    } = _ref4;
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].read) {
      // It's not accessible in any way, so we can't expose the related field
      return [];
    } // to-one relationships are much easier to deal with.


    if (!this.many) {
      return {
        [this.path]: (item, _, context, info) => {
          // No ID set, so we return null for the value
          if (!item[this.path]) {
            return null;
          }

          const filteredQueryArgs = {
            where: {
              id: item[this.path].toString()
            }
          }; // We do a full query to ensure things like access control are applied

          return refList.listQuery(filteredQueryArgs, context, refList.gqlNames.listQueryName, info).then(items => items && items.length ? items[0] : null);
        }
      };
    }

    return _objectSpread$7({
      [this.path]: (item, args, context, info) => {
        return refList.listQuery(args, context, info.fieldName, info, {
          fromList: this.getListByKey(this.listKey),
          fromId: item.id,
          fromField: this.path
        });
      }
    }, this.withMeta && {
      ["_".concat(this.path, "Meta")]: (item, args, context, info) => {
        return refList.listQueryMeta(args, context, info.fieldName, info, {
          fromList: this.getListByKey(this.listKey),
          fromId: item.id,
          fromField: this.path
        });
      }
    });
  }
  /**
   * @param operations {Object}
   * {
   *   disconnectAll?: Boolean, (default: false),
   *   disconnect?: Array<where>, (default: []),
   *   connect?: Array<where>, (default: []),
   *   create?: Array<data>, (default: []),
   * }
   * NOTE: If `disconnectAll` is `true`, `disconnect` is ignored.
   * `where` is a WhereUniqueInput (eg; { id: "abc123" })
   * `data` is an input of the type expected for the ref list (eg; { data: { name: "Sarah" } })
   *
   * @return {Object}
   * {
   *   disconnect: Array<ID>,
   *   connect: Array<ID>,
   *   create: Array<ID>,
   * }
   * The indexes within the return arrays are guaranteed to match the indexes as
   * passed in `operations`.
   * Due to Access Control, it is possible thata some operations result in a
   * value of `null`. Be sure to guard against this in your code.
   * NOTE: If `disconnectAll` is true, `disconnect` will be an array of all
   * previous stored values, which means indecies may not match those passed in
   * `operations`.
   */


  async resolveNestedOperations(operations, item, context, getItem, mutationState) {
    const {
      refList,
      refField
    } = this.tryResolveRefList();
    const listInfo = {
      local: {
        list: this.getListByKey(this.listKey),
        field: this
      },
      foreign: {
        list: refList,
        field: refField
      }
    }; // Possible early out for null'd field
    // prettier-ignore

    if (!operations && ( // If the field is not required, and the value is `null`, we can ignore
    // it and move on.
    !this.isRequired // This field will be backlinked to this field's containing item, so we
    // can safely ignore it now expecing the backlinking process in the
    // calling code to take care of it.
    || refField && this.getListByKey(refField.refListKey) === listInfo.local.list)) {
      // Don't release the zalgo; always return a promise.
      return Promise.resolve({
        create: [],
        connect: [],
        disconnect: []
      });
    }

    let currentValue;

    if (this.many) {
      const info = {
        fieldName: this.path
      };
      currentValue = item ? await refList.listQuery({}, _objectSpread$7({}, context, {
        getListAccessControlForUser: () => true
      }), info.fieldName, info, {
        fromList: this.getListByKey(this.listKey),
        fromId: item.id,
        fromField: this.path
      }) : [];
      currentValue = currentValue.map(_ref5 => {
        let {
          id
        } = _ref5;
        return id.toString();
      });
    } else {
      currentValue = item && item[this.path];
      currentValue = currentValue && currentValue.toString();
    } // Collect the IDs to be connected and disconnected. This step may trigger
    // createMutation calls in order to obtain these IDs if required.


    const {
      create = [],
      connect = [],
      disconnect = []
    } = await resolveNested({
      input: operations,
      currentValue,
      listInfo,
      many: this.many,
      context,
      mutationState
    }); // Enqueue backlink operations for the connections and disconnections

    if (refField) {
      enqueueBacklinkOperations({
        connect: [...create, ...connect],
        disconnect
      }, mutationState.queues, getItem || Promise.resolve(item), listInfo.local, listInfo.foreign);
    }

    return {
      create,
      connect,
      disconnect,
      currentValue
    };
  }

  registerBacklink(data, item, mutationState) {
    // Early out for null'd field
    if (!data) {
      return;
    }

    const {
      refList,
      refField
    } = this.tryResolveRefList();

    if (refField) {
      enqueueBacklinkOperations({
        disconnect: this.many ? data : [data]
      }, mutationState.queues, Promise.resolve(item), {
        list: this.getListByKey(this.listKey),
        field: this
      }, {
        list: refList,
        field: refField
      });
    } // TODO: Cascade _deletion_ of any related items (not just setting the
    // reference to null)
    // Accept a config option for cascading: https://www.prisma.io/docs/1.4/reference/service-configuration/data-modelling-(sdl)-eiroozae8u/#the-@relation-directive
    // Beware of circular delete hooks!

  }

  getGqlAuxTypes(_ref6) {
    let {
      schemaName
    } = _ref6;
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].update) {
      return [];
    } // We need an input type that is specific to creating nested items when
    // creating a relationship, ie;
    //
    // eg: Creating a new post at the same time as a new user
    // mutation createUser() {
    //   posts: [{ create: { title: 'Foobar' } }]
    // }
    //
    // Or, the inverse: Creating a new user at the same time as a new post
    // mutation createPost() {
    //   author: { create: { email: 'eg@example.com' } }
    // }
    //
    // Then there's the linking to existing records usecase:
    // mutation createPost() {
    //   author: { connect: { id: 'abc123' } }
    // }


    if (this.many) {
      return ["\n        input ".concat(refList.gqlNames.relateToManyInputName, " {\n          # Provide data to create a set of new ").concat(refList.key, ". Will also connect.\n          create: [").concat(refList.gqlNames.createInputName, "]\n\n          # Provide a filter to link to a set of existing ").concat(refList.key, ".\n          connect: [").concat(refList.gqlNames.whereUniqueInputName, "]\n\n          # Provide a filter to remove to a set of existing ").concat(refList.key, ".\n          disconnect: [").concat(refList.gqlNames.whereUniqueInputName, "]\n\n          # Remove all ").concat(refList.key, " in this list.\n          disconnectAll: Boolean\n        }\n      ")];
    }

    return ["\n      input ".concat(refList.gqlNames.relateToOneInputName, " {\n        # Provide data to create a new ").concat(refList.key, ".\n        create: ").concat(refList.gqlNames.createInputName, "\n\n        # Provide a filter to link to an existing ").concat(refList.key, ".\n        connect: ").concat(refList.gqlNames.whereUniqueInputName, "\n\n        # Provide a filter to remove to an existing ").concat(refList.key, ".\n        disconnect: ").concat(refList.gqlNames.whereUniqueInputName, "\n\n        # Remove the existing ").concat(refList.key, " (if any).\n        disconnectAll: Boolean\n      }\n    ")];
  }

  get gqlUpdateInputFields() {
    const {
      refList
    } = this.tryResolveRefList();

    if (this.many) {
      return ["".concat(this.path, ": ").concat(refList.gqlNames.relateToManyInputName)];
    }

    return ["".concat(this.path, ": ").concat(refList.gqlNames.relateToOneInputName)];
  }

  get gqlCreateInputFields() {
    return this.gqlUpdateInputFields;
  }

}

class MongoRelationshipInterface extends MongooseFieldAdapter {
  constructor() {
    super(...arguments); // JM: It bugs me this is duplicated in the implementation but initialisation order makes it hard to avoid

    const [refListKey, refFieldPath] = this.config.ref.split('.');
    this.refListKey = refListKey;
    this.refFieldPath = refFieldPath;
    this.isRelationship = true;
  }

  addToMongooseSchema(schema) {
    const {
      refListKey: ref,
      config: {
        many
      }
    } = this;
    const type = many ? [ObjectId$1] : ObjectId$1;
    const schemaOptions = {
      type,
      ref
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

  getRefListAdapter() {
    return this.getListByKey(this.refListKey).adapter;
  }

  getQueryConditions(dbPath) {
    return {
      ["".concat(this.path, "_is_null")]: value => ({
        [dbPath]: value ? {
          $not: {
            $exists: true,
            $ne: null
          }
        } : {
          $exists: true,
          $ne: null
        }
      })
    };
  }

  supportsRelationshipQuery(query) {
    return [this.path, "".concat(this.path, "_every"), "".concat(this.path, "_some"), "".concat(this.path, "_none")].includes(query);
  }

}

class KnexRelationshipInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments);
    this.isRelationship = true; // Default isIndexed to true if it's not explicitly provided
    // Mutually exclusive with isUnique

    this.isUnique = typeof this.config.isUnique === 'undefined' ? false : !!this.config.isUnique;
    this.isIndexed = typeof this.config.isIndexed === 'undefined' ? !this.config.isUnique : !!this.config.isIndexed; // JM: It bugs me this is duplicated in the implementation but initialisation order makes it hard to avoid

    const [refListKey, refFieldPath] = this.config.ref.split('.');
    this.refListKey = refListKey;
    this.refFieldPath = refFieldPath;
    this.refListId = "".concat(refListKey, "_id");
  } // Override the isNotNullable defaulting logic; default to false, not field.isRequired
  // Non-nullability of foreign keys in a one-to-many configuration causes problems with complicates creates
  // It implies a precedence in ordering of create operations and can break the nexted create resolvers
  // Also, if a pair of list both have a non-nullable relationship with the other, all inserts on either will fail


  get isNotNullable() {
    if (this._isNotNullable) return this._isNotNullable;
    return this._isNotNullable = !!(typeof this.knexOptions.isNotNullable === 'undefined' ? false : this.knexOptions.isNotNullable);
  }

  getRefListAdapter() {
    return this.getListByKey(this.refListKey).adapter;
  }

  addToTableSchema(table) {
    // If we're relating to 'many' things, we don't store ids in this table
    if (!this.field.many) {
      // The foreign key needs to do this work for us; we don't know what type it is
      const refList = this.getListByKey(this.refListKey);
      const refId = refList.getPrimaryKey();
      const foreignKeyConfig = {
        path: this.path,
        isUnique: this.isUnique,
        isIndexed: this.isIndexed,
        isNotNullable: this.isNotNullable
      };
      refId.adapter.addToForeignTableSchema(table, foreignKeyConfig);
    }
  }

  getQueryConditions(dbPath) {
    return {
      ["".concat(this.path, "_is_null")]: value => b => value ? b.whereNull(dbPath) : b.whereNotNull(dbPath)
    };
  }

  supportsRelationshipQuery(query) {
    return [this.path, "".concat(this.path, "_every"), "".concat(this.path, "_some"), "".concat(this.path, "_none")].includes(query);
  }

}

var RelationshipType = {
  type: 'Relationship',
  isRelationship: true,
  // Used internally for this special case
  implementation: Relationship,
  views: {
    Controller: _join(__dirname, "1n73jn1"),
    Field: _join(__dirname, "15in0wx"),
    Filter: _join(__dirname, "t8xlg4"),
    Cell: _join(__dirname, "1ngepfp")
  },
  adapters: {
    mongoose: MongoRelationshipInterface,
    knex: KnexRelationshipInterface
  },
  resolveBacklinks
};

function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$8(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const RelationshipWrapper = _objectSpread$8({}, RelationshipType, {
  implementation: class extends RelationshipType.implementation {
    async resolveNestedOperations(operations, item, context) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      const result = await super.resolveNestedOperations(operations, item, context, ...args);
      context._blockMeta = context._blockMeta || {};
      context._blockMeta[this.listKey] = context._blockMeta[this.listKey] || {};
      context._blockMeta[this.listKey][this.path] = result;
      return result;
    }

  }
});

class ImageBlock extends Block {
  constructor(_ref, _ref2) {
    let {
      adapter
    } = _ref;
    let {
      fromList,
      joinList,
      createAuxList,
      getListByKey
    } = _ref2;
    super(...arguments);
    this.joinList = joinList;
    const auxListKey = "_Block_".concat(fromList, "_").concat(this.type); // Ensure the list is only instantiated once per server instance.

    let auxList = getListByKey(auxListKey);

    if (!auxList) {
      auxList = createAuxList(auxListKey, {
        fields: {
          image: {
            type: CloudinaryImage$1,
            isRequired: true,
            adapter,
            schemaDoc: 'Cloudinary Image data returned from the Cloudinary API'
          },
          align: {
            type: SelectType,
            defaultValue: 'center',
            options: ['left', 'center', 'right'],
            schemaDoc: 'Set the image alignment'
          },
          // Useful for doing reverse lookups such as:
          // - "Get all images in this post"
          // - "List all users mentioned in comment"
          from: {
            type: RelationshipType,
            isRequired: true,
            ref: "".concat(joinList, ".").concat(this.path),
            schemaDoc: 'A reference back to the Slate.js Serialised Document this image is embedded within'
          }
        }
      });
    }

    this.auxList = auxList;
  }

  get type() {
    return 'cloudinaryImage';
  }

  get path() {
    return pluralize.plural(this.type);
  }

  getAdminViews() {
    return [_join(__dirname, "clgmao"), ...new imageContainer().getAdminViews(), ...new caption().getAdminViews()];
  }

  getFieldDefinitions() {
    return {
      [this.path]: {
        type: RelationshipWrapper,
        ref: "".concat(this.auxList.key, ".from"),
        many: true,
        schemaDoc: 'Images which have been added to the Content field'
      }
    };
  }

  getMutationOperationResults(_ref3) {
    let {
      context
    } = _ref3;
    return {
      [this.path]: context._blockMeta && context._blockMeta[this.joinList] && context._blockMeta[this.joinList][this.path]
    };
  }

  getViewOptions() {
    return {
      query: "\n        cloudinaryImages {\n          id\n          image {\n            publicUrl\n          }\n          align\n        }\n      "
    };
  }

}

var CloudinaryImage$1 = {
  type: 'CloudinaryImage',
  implementation: CloudinaryImage,
  views: {
    Controller: _join(__dirname, "haf47u"),
    Field: _join(__dirname, "cnpn6s"),
    Cell: _join(__dirname, "1omu7q8")
  },
  adapters: {
    mongoose: MongoFileInterface,
    knex: KnexFileInterface
  },
  blocks: {
    image: ImageBlock // gallery: {
    //   type: 'cloudinaryGallery',
    // },

  }
};

function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$9(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Text extends Field {
  constructor(path, _ref) {
    let {
      isMultiline
    } = _ref;
    super(...arguments);
    this.isMultiline = isMultiline;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": String")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.equalityInputFieldsInsensitive('String'), ...this.stringInputFieldsInsensitive('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  extendAdminMeta(meta) {
    const {
      isMultiline
    } = this;
    return _objectSpread$9({
      isMultiline
    }, meta);
  }

}

const CommonTextInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$9({}, this.equalityConditions(dbPath), {}, this.stringConditions(dbPath), {}, this.equalityConditionsInsensitive(dbPath), {}, this.stringConditionsInsensitive(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoTextInterface extends CommonTextInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }

}

class KnexTextInterface extends CommonTextInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.text(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var index$2 = {
  type: 'Color',
  implementation: Text,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "rb66go"),
    Cell: _join(__dirname, "1fzegpt"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$a(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$a(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class _DateTime extends Field {
  constructor(path, _ref) {
    let {
      format,
      yearRangeFrom,
      yearRangeTo,
      yearPickerType
    } = _ref;
    super(...arguments);
    this.format = format;
    this.yearRangeFrom = yearRangeFrom;
    this.yearRangeTo = yearRangeTo;
    this.yearPickerType = yearPickerType;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": DateTime")];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('DateTime'), ...this.orderingInputFields('DateTime'), ...this.inInputFields('DateTime')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": DateTime")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": DateTime")];
  }

  getGqlAuxTypes() {
    return ["scalar DateTime"];
  }

  extendAdminMeta(meta) {
    return _objectSpread$a({}, meta, {
      format: this.format,
      yearRangeFrom: this.yearRangeFrom,
      yearRangeTo: this.yearRangeTo,
      yearPickerType: this.yearPickerType
    });
  }

  gqlAuxFieldResolvers() {
    return {
      DateTime: new GraphQLScalarType({
        name: 'DateTime',
        description: 'DateTime custom scalar represents an ISO 8601 datetime string',

        parseValue(value) {
          return value; // value from the client
        },

        serialize(value) {
          return value; // value sent to the client
        },

        parseLiteral(ast) {
          if (ast.kind === Kind.STRING) {
            return ast.value; // ast value is always in string format
          }

          return null;
        }

      })
    };
  }

}

const toDate = s => s && DateTime.fromISO(s, {
  zone: 'utc'
}).toJSDate();

const CommonDateTimeInterface = superclass => class extends superclass {
  setupHooks(_ref2) {
    let {
      addPreSaveHook,
      addPostReadHook
    } = _ref2;
    const field_path = this.path;
    const utc_field = "".concat(field_path, "_utc");
    const offset_field = "".concat(field_path, "_offset"); // Updates the relevant value in the item provided (by referrence)

    addPreSaveHook(item => {
      // Only run the hook if the item actually contains the datetime field
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO
      if (!(field_path in item)) {
        return item;
      }

      const datetimeString = item[field_path]; // NOTE: Even though `0` is a valid timestamp (the unix epoch), it's not a valid ISO string,
      // so it's ok to check for falseyness here.

      if (!datetimeString) {
        item[utc_field] = null;
        item[offset_field] = null;
        delete item[field_path]; // Never store this field

        return item;
      }

      if (!DateTime.fromISO(datetimeString, {
        zone: 'utc'
      }).isValid) {
        throw new Error('Validation failed: DateTime must be either `null` or a valid ISO 8601 string');
      }

      item[utc_field] = toDate(datetimeString);
      item[offset_field] = DateTime.fromISO(datetimeString, {
        setZone: true
      }).toFormat('ZZ');
      delete item[field_path]; // Never store this field

      return item;
    });
    addPostReadHook(item => {
      // If there's no fields stored in the DB (can happen with MongoDB), then
      // don't bother trying to process anything
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO
      if (!(utc_field in item) && !(offset_field in item)) {
        return item;
      }

      if (!item[utc_field] || !item[offset_field]) {
        item[field_path] = null;
        return item;
      }

      const datetimeString = DateTime.fromJSDate(item[utc_field], {
        zone: 'utc'
      }).setZone(new FixedOffsetZone(DateTime.fromISO("1234-01-01T00:00:00".concat(item[offset_field]), {
        setZone: true
      }).offset)).toISO();
      item[field_path] = datetimeString;
      item[utc_field] = undefined;
      item[offset_field] = undefined;
      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread$a({}, this.equalityConditions(dbPath, toDate), {}, this.orderingConditions(dbPath, toDate), {}, this.inConditions(dbPath, toDate));
  }

};

class MongoDateTimeInterface extends CommonDateTimeInterface(MongooseFieldAdapter) {
  constructor() {
    super(...arguments);
    this.dbPath = "".concat(this.path, "_utc");
  }

  addToMongooseSchema(schema) {
    const {
      mongooseOptions
    } = this.config;
    const field_path = this.path;
    const utc_field = "".concat(field_path, "_utc");
    const offset_field = "".concat(field_path, "_offset");
    schema.add({
      // FIXME: Mongoose needs to know about this field in order for the correct
      // attributes to make it through to the pre-hooks.
      [field_path]: _objectSpread$a({
        type: String
      }, mongooseOptions),
      // These are the actual fields we care about storing in the database.
      [utc_field]: _objectSpread$a({
        type: Date
      }, mongooseOptions),
      [offset_field]: _objectSpread$a({
        type: String
      }, mongooseOptions)
    });
  }

  getMongoFieldName() {
    return "".concat(this.path, "_utc");
  }

}

class KnexDateTimeInterface extends CommonDateTimeInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.utcPath = "".concat(this.path, "_utc");
    this.offsetPath = "".concat(this.path, "_offset");
    this.realKeys = [this.utcPath, this.offsetPath];
    this.sortKey = this.utcPath;
    this.dbPath = this.utcPath;
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    // TODO: Should use a single field on PG
    // .. although 2 cols is nice for MySQL (no native datetime with tz)
    const utcColumn = table.timestamp(this.utcPath, {
      useTz: false
    });
    const offsetColumn = table.text(this.offsetPath); // Interpret the index options as effecting both elements

    if (this.isUnique) table.unique([this.utcPath, this.offsetPath]);else if (this.isIndexed) table.index([this.utcPath, this.offsetPath]); // Interpret not nullable to mean neither field is nullable

    if (this.isNotNullable) {
      utcColumn.notNullable();
      offsetColumn.notNullable();
    } // Allow defaults to be set for both elements of the value by nesting them
    // TODO: Add to docs..


    if (this.defaultTo && (this.defaultTo.utc || this.defaultTo.offset)) {
      if (this.defaultTo.utc) utcColumn.defaultTo(this.defaultTo.utc);
      if (this.defaultTo.offset) offsetColumn.defaultTo(this.defaultTo.offset);
    } else if (this.defaultTo) {
      utcColumn.defaultTo(this.defaultTo);
    }
  }

}

var index$3 = {
  type: 'DateTime',
  implementation: _DateTime,
  views: {
    Controller: _join(__dirname, "hlr4ay"),
    Field: _join(__dirname, "1r0c33v"),
    Filter: _join(__dirname, "15zs31"),
    Cell: _join(__dirname, "crtxqs")
  },
  adapters: {
    mongoose: MongoDateTimeInterface,
    knex: KnexDateTimeInterface
  }
};

function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$b(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$b(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Decimal extends Field {
  constructor(path, _ref) {
    let {
      symbol
    } = _ref;
    super(...arguments);
    this.symbol = symbol;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": String")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.orderingInputFields('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  extendAdminMeta(meta) {
    return _objectSpread$b({}, meta, {
      symbol: this.symbol
    });
  }

}

class MongoDecimalInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    const validator = a => typeof a === 'object' && /^-?\d*\.?\d*$/.test(a);

    const schemaOptions = {
      type: mongoose.Decimal128,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not a Decimal value'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

  setupHooks(_ref2) {
    let {
      addPreSaveHook,
      addPostReadHook
    } = _ref2; // Updates the relevant value in the item provided (by reference)

    addPreSaveHook(item => {
      if (item[this.path] && typeof item[this.path] === 'string') {
        item[this.path] = mongoose.Types.Decimal128.fromString(item[this.path]);
      } else if (!item[this.path]) {
        item[this.path] = null;
      } // else: Must either be undefined or a Decimal128 object, so leave it alone.


      return item;
    });
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = item[this.path].toString();
      }

      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread$b({}, this.equalityConditions(dbPath, mongoose.Types.Decimal128.fromString), {}, this.orderingConditions(dbPath, mongoose.Types.Decimal128.fromString), {}, this.inConditions(dbPath, mongoose.Types.Decimal128.fromString));
  }

}

class KnexDecimalInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique; // In addition to the standard knexOptions this type supports precision and scale

    const {
      precision,
      scale
    } = this.knexOptions;
    this.precision = precision === null ? null : parseInt(precision) || 18;
    this.scale = scale === null ? null : (this.precision, parseInt(scale) || 4);

    if (this.scale !== null && this.precision !== null && this.scale > this.precision) {
      throw "The scale configured for Decimal field '".concat(this.path, "' (").concat(this.scale, ") ") + "must not be larger than the field's precision (".concat(this.precision, ")");
    }
  }

  addToTableSchema(table) {
    const column = table.decimal(this.path, this.precision, this.scale);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

  getQueryConditions(dbPath) {
    return _objectSpread$b({}, this.equalityConditions(dbPath), {}, this.orderingConditions(dbPath), {}, this.inConditions(dbPath));
  }

}

var index$4 = {
  type: 'Decimal',
  implementation: Decimal,
  views: {
    Controller: _join(__dirname, "118m09z"),
    Field: _join(__dirname, "sg6d6v"),
    Filter: _join(__dirname, "14ybajw")
  },
  adapters: {
    mongoose: MongoDecimalInterface,
    knex: KnexDecimalInterface
  }
};
var index$5 = {
  type: 'File',
  implementation: File,
  views: {
    Controller: _join(__dirname, "tbs8uc"),
    Field: _join(__dirname, "kpf3q7"),
    Cell: _join(__dirname, "53k0ro")
  },
  adapters: {
    mongoose: MongoFileInterface,
    knex: KnexFileInterface
  }
};

function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$c(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$c(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Float extends Field {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": Float")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('Float'), ...this.orderingInputFields('Float'), ...this.inInputFields('Float')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": Float")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": Float")];
  }

}

const CommonFloatInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$c({}, this.equalityConditions(dbPath), {}, this.orderingConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoFloatInterface extends CommonFloatInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Number
      }, this.config)
    });
  }

}

class KnexFloatInterface extends CommonFloatInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.float(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var index$6 = {
  type: 'Float',
  implementation: Float,
  views: {
    Controller: _join(__dirname, "ahdnug"),
    Field: _join(__dirname, "1af09zh"),
    Filter: _join(__dirname, "7hd0gj")
  },
  adapters: {
    mongoose: MongoFloatInterface,
    knex: KnexFloatInterface
  }
};

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$d(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$d(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Integer extends Field {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": Int")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('Int'), ...this.orderingInputFields('Int'), ...this.inInputFields('Int')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": Int")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": Int")];
  }

}

const CommonIntegerInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$d({}, this.equalityConditions(dbPath), {}, this.orderingConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoIntegerInterface extends CommonIntegerInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Number,
      validate: {
        validator: this.buildValidator(a => typeof a === 'number' && Number.isInteger(a)),
        message: '{VALUE} is not an integer value'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexIntegerInterface extends CommonIntegerInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.integer(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var index$7 = {
  type: 'Integer',
  implementation: Integer,
  views: {
    Controller: _join(__dirname, "ua0r21"),
    Field: _join(__dirname, "ogdh30"),
    Filter: _join(__dirname, "1izcksw")
  },
  adapters: {
    mongoose: MongoIntegerInterface,
    knex: KnexIntegerInterface
  }
};

function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$e(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$e(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
} // https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md#checking-if-a-path-is-populated


mongoose.set('objectIdGetter', false);
const {
  Types: {
    ObjectId: ObjectId$2
  }
} = mongoose;

class Location extends Field {
  constructor(_, _ref) {
    let {
      googleMapsKey
    } = _ref;
    super(...arguments);
    this.graphQLOutputType = 'Location';

    if (!googleMapsKey) {
      throw new Error('You must provide a `googleMapsKey` to Location Field. To generate a Google Maps API please visit: https://developers.google.com/maps/documentation/javascript/get-api-key');
    }

    this._googleMapsKey = googleMapsKey;
  }

  extendAdminMeta(meta) {
    return _objectSpread$e({}, meta, {
      googleMapsKey: this._googleMapsKey
    });
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.graphQLOutputType)];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    return ["\n      type ".concat(this.graphQLOutputType, " {\n        id: ID\n        googlePlaceID: String\n        formattedAddress: String\n        lat: Float\n        lng: Float\n      }\n    ")];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        }

        return itemValues;
      }
    };
  }

  async resolveInput(_ref2) {
    let {
      resolvedData
    } = _ref2;
    const placeId = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputId) return inputId`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof placeId === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (placeId === null) {
      // `null` was specifically set, and we should set the field value to null
      // To do that we... return `null`
      return null;
    }

    const response = await fetch("https://maps.googleapis.com/maps/api/geocode/json?place_id=".concat(placeId, "&key=").concat(this._googleMapsKey)).then(r => r.json());

    if (response.results && response.results[0]) {
      const {
        place_id,
        formatted_address
      } = response.results[0];
      const {
        lat,
        lng
      } = response.results[0].geometry.location;
      return {
        id: new ObjectId$2(),
        googlePlaceID: place_id,
        formattedAddress: formatted_address,
        lat: lat,
        lng: lng
      };
    }

    return null;
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

}

const CommonLocationInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$e({}, this.equalityConditions(dbPath), {}, this.stringConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoLocationInterface extends CommonLocationInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: {
        id: ObjectId$2,
        googlePlaceID: String,
        formattedAddress: String,
        lat: Number,
        lng: Number
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexLocationInterface extends CommonLocationInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw "The Location field type doesn't support indexes on Knex. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

var index$8 = {
  type: 'Location',
  implementation: Location,
  views: {
    Controller: _join(__dirname, "4u4ry3"),
    Field: _join(__dirname, "cnp9lf"),
    Cell: _join(__dirname, "1u3lhxi"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    mongoose: MongoLocationInterface,
    knex: KnexLocationInterface
  }
};

function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$f(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$f(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class OEmbed extends Field {
  constructor(path, _ref, _ref2) {
    let {
      adapter,
      parameters = {}
    } = _ref;
    let {
      listKey
    } = _ref2;
    super(...arguments);

    if (!adapter) {
      throw new Error("An OEmbed Adapter must be supplied for the OEmbed field to fetch oEmbed data. See the ".concat(listKey, ".").concat(path, " field."));
    }

    if (typeof adapter.fetch !== 'function') {
      throw new Error("An invalid OEmbed Adapter was set on the ".concat(listKey, ".").concat(path, " field - it does not implement the #fetch() method."));
    }

    if (typeof parameters !== 'object') {
      throw new Error("parameters passed to the OEmbed Adapter must be an object. See the ".concat(listKey, ".").concat(path, " field."));
    }

    this.graphQLOutputType = 'OEmbed';
    this.adapter = adapter;
    this.parameters = parameters;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.graphQLOutputType)];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    const baseFields = "\n      # The resource type. One of 'photo'/'video'/'link'/'rich'\n      type: String!\n      # The original input URL which the oEmbed data was generated from\n      originalUrl: String!\n      # The oEmbed version number. Will be 1.0.\n      version: String!\n      # A text title, describing the resource.\n      title: String\n      # The suggested cache lifetime for this resource, in seconds. Consumers may choose to use this value or not.\n      cacheAge: String\n      # The resource provider.\n      provider: ".concat(this.graphQLOutputType, "Provider\n      # The author/owner of the resource.\n      author: ").concat(this.graphQLOutputType, "Author\n      # An optional thumbnail image representing the resource.\n      thumbnail: ").concat(this.graphQLOutputType, "Thumbnail\n    ");
    return ["\n        type ".concat(this.graphQLOutputType, "Thumbnail {\n          # A URL to a thumbnail image\n          url: String!\n          # The width of the thumbnail in pixels\n          width: String!\n          # The height of the thumbnail\n          height: String!\n        }\n      "), "\n        type ".concat(this.graphQLOutputType, "Author {\n          # The name of the author/owner of the resource.\n          name: String\n          # A URL for the author/owner of the resource.\n          url: String\n        }\n      "), "\n        type ".concat(this.graphQLOutputType, "Provider {\n          # The name of the resource provider.\n          name: String\n          # The url of the resource provider.\n          url: String\n        }\n      "), "\n        \"\"\"\n        The base ".concat(this.graphQLOutputType, " type.\n        See the following implementations:\n        - ").concat(this.graphQLOutputType, "Link\n        - ").concat(this.graphQLOutputType, "Photo\n        - ").concat(this.graphQLOutputType, "Video\n        - ").concat(this.graphQLOutputType, "Rich\n        \"\"\"\n        interface ").concat(this.graphQLOutputType, " {\n          ").concat(baseFields, "\n        }\n      "), // NOTE: The Link type only implements the base fields
    "\n        # Generic embed data.\n        type ".concat(this.graphQLOutputType, "Link implements ").concat(this.graphQLOutputType, " {\n          ").concat(baseFields, "\n        }\n      "), "\n        # This type is used for representing static photos in oEmbed data.\n        type ".concat(this.graphQLOutputType, "Photo implements ").concat(this.graphQLOutputType, " {\n          ").concat(baseFields, "\n          # The source URL of the image. Consumers should be able to insert this URL into an <img> element. Only HTTP and HTTPS URLs are valid.\n          url: String!\n          # The width in pixels of the image\n          width: String\n          # The height in pixels of the image\n          height: String\n        }\n      "), "\n        # This type is used for representing playable videos in oEmbed data.\n        type ".concat(this.graphQLOutputType, "Video implements ").concat(this.graphQLOutputType, " {\n          ").concat(baseFields, "\n          # The HTML required to embed a video player. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities.\n          html: String!\n          # The width in pixels required to display the HTML.\n          width: String\n          # The height in pixels required to display the HTML.\n          height: String\n        }\n      "), "\n        # This type is used for rich HTML content that does not fall under ".concat(this.graphQLOutputType, "Link, ").concat(this.graphQLOutputType, "Photo, or ").concat(this.graphQLOutputType, "Video.\n        type ").concat(this.graphQLOutputType, "Rich implements ").concat(this.graphQLOutputType, " {\n          ").concat(baseFields, "\n          # The HTML required to display the resource. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities. The markup should be valid XHTML 1.0 Basic.\n          html: String!\n          # The width in pixels required to display the HTML.\n          width: String\n          # The height in pixels required to display the HTML.\n          height: String\n        }\n      ")];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        if (!item[this.path]) {
          return null;
        } // Because we're returning an interface, we have to tell GraphQL what
        // __typename to use.


        let __typename = {
          photo: "".concat(this.graphQLOutputType, "Photo"),
          video: "".concat(this.graphQLOutputType, "Video"),
          link: "".concat(this.graphQLOutputType, "Link"),
          rich: "".concat(this.graphQLOutputType, "Rich")
        }[item[this.path].type];
        return _objectSpread$f({}, item[this.path], {
          __typename
        });
      }
    };
  }

  async resolveInput(_ref3) {
    let {
      resolvedData
    } = _ref3;
    const inputUrl = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputUrl) return inputUrl`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof inputUrl === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (inputUrl === null || inputUrl.trim() === '') {
      // `null` or `''` was specifically uploaded, and we should set the field
      // value to null. To do that we... return `null`
      return null;
    } // Pull all possible oEmbed fields from the adapter


    const {
      type,
      version,
      title,
      author_name,
      author_url,
      provider_name,
      provider_url,
      cache_age,
      thumbnail_url,
      thumbnail_width,
      thumbnail_height,
      url,
      html,
      width,
      height
    } = await this.adapter.fetch(_objectSpread$f({}, this.parameters, {
      // Force the url parameter
      url: inputUrl
    })); // Convert them into a more GraphQL friendly format

    return {
      originalUrl: inputUrl,
      type,
      version,
      title,
      cache_age,
      // Only parts of the author might exist
      author: author_name || author_url ? {
        name: author_name || null,
        url: author_url || null
      } : null,
      // Only parts of the author might exist
      provider: provider_name || provider_url ? {
        name: provider_name || null,
        url: provider_url || null
      } : null,
      // All fields of thumbnail are required
      thumbnail: thumbnail_url && thumbnail_width && thumbnail_height ? {
        url: thumbnail_url,
        width: thumbnail_width,
        height: thumbnail_height
      } : null,
      url,
      html,
      width,
      height
    };
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

}

const CommonOEmbedInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$f({}, this.equalityConditions(dbPath), {}, this.stringConditions(dbPath), {}, this.inConditions(dbPath));
  }

};

class MongoOEmbedInterface extends CommonOEmbedInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Object
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexOEmbedInterface extends CommonOEmbedInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw "The OEmbed field type doesn't support indexes on Knex. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

function ownKeys$g(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$g(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$g(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const RelationshipWrapper$1 = _objectSpread$g({}, RelationshipType, {
  implementation: class extends RelationshipType.implementation {
    async resolveNestedOperations(operations, item, context) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      const result = await super.resolveNestedOperations(operations, item, context, ...args);
      context._blockMeta = context._blockMeta || {};
      context._blockMeta[this.listKey] = context._blockMeta[this.listKey] || {};
      context._blockMeta[this.listKey][this.path] = result;
      return result;
    }

  }
});

class OEmbedBlock extends Block {
  constructor(_ref, _ref2) {
    let {
      adapter
    } = _ref;
    let {
      fromList,
      joinList,
      createAuxList,
      getListByKey
    } = _ref2;
    super(...arguments);
    this.joinList = joinList;
    this.adapter = adapter;
    const auxListKey = "_Block_".concat(fromList, "_").concat(this.type); // Ensure the list is only instantiated once per server instance.

    let auxList = getListByKey(auxListKey);

    if (!auxList) {
      auxList = createAuxList(auxListKey, {
        fields: {
          embed: {
            type: OEmbed$1,
            isRequired: true,
            adapter,
            schemaDoc: 'oEmbed data as returned by the passed adapter'
          },
          // Useful for doing reverse lookups such as:
          // - "Get all embeds in this post"
          // - "List all users mentioned in comment"
          from: {
            type: RelationshipType,
            isRequired: true,
            ref: "".concat(joinList, ".").concat(this.path),
            schemaDoc: 'A reference back to the Slate.js Serialised Document this embed is contained within'
          }
        }
      });
    }

    this.auxList = auxList;
  }

  get type() {
    return 'oEmbed';
  }

  get path() {
    return pluralize.plural(this.type);
  }

  getFieldDefinitions() {
    return {
      [this.path]: {
        type: RelationshipWrapper$1,
        ref: "".concat(this.auxList.key, ".from"),
        many: true,
        schemaDoc: 'Embeds which have been added to the Content field'
      }
    };
  }

  getMutationOperationResults(_ref3) {
    let {
      context
    } = _ref3;
    return {
      [this.path]: context._blockMeta && context._blockMeta[this.joinList] && context._blockMeta[this.joinList][this.path]
    };
  }

  getAdminViews() {
    return [_join(__dirname, "ayx28x"), ...(typeof this.adapter.getAdminViews === 'function' ? this.adapter.getAdminViews() : [])];
  }

  getViewOptions() {
    return _objectSpread$g({
      query: "\n        oEmbeds {\n          id\n          embed {\n            ".concat(queryFragment, "\n          }\n        }\n      ")
    }, typeof this.adapter.getViewOptions === 'function' ? this.adapter.getViewOptions() : {});
  }

}

var OEmbed$1 = {
  type: 'OEmbed',
  implementation: OEmbed,
  views: {
    Controller: _join(__dirname, "wgjdbb"),
    Field: _join(__dirname, "1dqigo0"),
    Cell: _join(__dirname, "wa23jc")
  },
  adapters: {
    mongoose: MongoOEmbedInterface,
    knex: KnexOEmbedInterface
  },
  blocks: {
    oEmbed: OEmbedBlock
  }
};

function ownKeys$h(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$h(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$h(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const bcryptHashRegex = /^\$2[aby]?\$\d{1,2}\$[.\/A-Za-z0-9]{53}$/;

class Password extends Field {
  constructor(path, _ref) {
    let {
      rejectCommon,
      minLength,
      workFactor
    } = _ref;
    super(...arguments); // Sanitise field specific config

    this.rejectCommon = !!rejectCommon;
    this.minLength = Math.max(Number.parseInt(minLength) || 8, 1); // Min 4, max: 31, default: 10

    this.workFactor = Math.min(Math.max(Number.parseInt(workFactor) || 10, 4), 31);

    if (this.workFactor < 6) {
      console.warn("The workFactor for ".concat(this.listKey, ".").concat(this.path, " is very low! ") + "This will cause weak hashes!");
    }
  }

  gqlOutputFields() {
    return ["".concat(this.path, "_is_set: Boolean")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path, "_is_set")]: item => {
        const val = item[this.path];
        return bcryptHashRegex.test(val);
      }
    };
  }

  gqlQueryInputFields() {
    return ["".concat(this.path, "_is_set: Boolean")];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  } // Wrap bcrypt functionality
  // The compare() and compareSync() functions are constant-time
  // The compare() and generateHash() functions will return a Promise if no call back is provided


  compare(candidate, hash, callback) {
    return bcrypt.compare(candidate, hash, callback);
  }

  compareSync(candidate, hash) {
    return bcrypt.compareSync(candidate, hash);
  }

  generateHash(plaintext, callback) {
    this.validateNewPassword(plaintext);
    return bcrypt.hash(plaintext, this.workFactor, callback);
  }

  generateHashSync(plaintext) {
    this.validateNewPassword(plaintext);
    return bcrypt.hashSync(plaintext, this.workFactor);
  }

  extendAdminMeta(meta) {
    const {
      minLength
    } = this;
    return _objectSpread$h({}, meta, {
      minLength
    });
  } // Force values to be hashed when set


  validateNewPassword(password) {
    if (this.rejectCommon && dumbPasswords.check(password)) {
      throw new Error("[password:rejectCommon:".concat(this.listKey, ":").concat(this.path, "] Common and frequently-used passwords are not allowed."));
    } // TODO: checking string length is not simple; might need to revisit this (see https://mathiasbynens.be/notes/javascript-unicode)


    if (String(password).length < this.minLength) {
      throw new Error("[password:minLength:".concat(this.listKey, ":").concat(this.path, "] Value must be at least ").concat(this.minLength, " characters long."));
    }
  }

}

const CommonPasswordInterface = superclass => class extends superclass {
  setupHooks(_ref2) {
    let {
      addPreSaveHook
    } = _ref2; // Updates the relevant value in the item provided (by referrence)

    addPreSaveHook(async item => {
      const path = this.field.path;
      const plaintext = item[path];

      if (typeof plaintext === 'undefined') {
        return item;
      }

      if (String(plaintext) === plaintext && plaintext !== '') {
        item[path] = await this.field.generateHash(plaintext);
      } else {
        item[path] = null;
      }

      return item;
    });
  }

};

class MongoPasswordInterface extends CommonPasswordInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }

  getQueryConditions(dbPath) {
    return {
      ["".concat(this.path, "_is_set")]: value => ({
        [dbPath]: value ? {
          $regex: bcryptHashRegex
        } : {
          $not: bcryptHashRegex
        }
      })
    };
  }

}

class KnexPasswordInterface extends CommonPasswordInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config

    if (this.config.isUnique || this.config.isIndexed) {
      throw "The Password field type doesn't support indexes on Knex. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }

    if (this.config.defaultTo) {
      throw "The Password field type doesn't support the Knex 'defaultTo' config. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }
  }

  addToTableSchema(table) {
    const column = table.string(this.path, 60);
    if (this.isNotNullable) column.notNullable();
  }

  getQueryConditions(dbPath) {
    // JM: I wonder if performing a regex match here leaks any timing info that
    // could be used to extract information about the hash.. :/
    return {
      ["".concat(this.path, "_is_set")]: value => b => value ? b.where(dbPath, '~', bcryptHashRegex.source) : b.where(dbPath, '!~', bcryptHashRegex.source).orWhereNull(dbPath)
    };
  }

}

var index$9 = {
  type: 'Password',
  implementation: Password,
  views: {
    Controller: _join(__dirname, "1cbdcy"),
    Field: _join(__dirname, "3l3ke0"),
    Filter: _join(__dirname, "18x4cqz")
  },
  adapters: {
    mongoose: MongoPasswordInterface,
    knex: KnexPasswordInterface
  }
};

function ownKeys$i(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$i(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$i(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const MAX_UNIQUE_ATTEMPTS = 100;

const findFirstNonEmptyStringValue = fields => Object.values(fields).find(value => typeof value === 'string' && value);

const generateSlug = valueToSlugify => slugify(valueToSlugify || '');

class SlugImplementation extends Text {
  constructor(path, _ref, _ref2) {
    let {
      from,
      generate,
      makeUnique,
      alwaysMakeUnique = false,
      isUnique,
      regenerateOnUpdate = true
    } = _ref;
    let {
      listKey
    } = _ref2;
    const listAndFieldPath = "".concat(listKey, ".").concat(path);

    if (typeof regenerateOnUpdate !== 'boolean') {
      throw new Error("The 'regenerateOnUpdate' option on ".concat(listAndFieldPath, " must be true/false"));
    }

    if (typeof alwaysMakeUnique !== 'boolean') {
      throw new Error("The 'alwaysMakeUnique' option on ".concat(listAndFieldPath, " must be true/false"));
    }

    if (from && generate) {
      throw new Error("Only one of 'from' or 'generate' can be supplied as an option to the Slug field on ".concat(listAndFieldPath, "."));
    }

    let generateFn;
    let makeUniqueFn;

    if (from) {
      if (typeof from !== 'string') {
        if (typeof from === 'function') {
          throw new Error("A function was specified for the 'from' option on ".concat(listAndFieldPath, ", but 'from' exects a string. Did you mean to set the 'generate' option?"));
        }

        throw new Error("The 'from' option on ".concat(listAndFieldPath, " must be a string"));
      }

      generateFn = _ref3 => {
        let {
          resolvedData,
          existingItem
        } = _ref3; // Look up fields on the list to ensure a valid field was passed

        if (!this.getListByKey(this.listKey).getFieldByPath(from)) {
          throw new Error("The field '".concat(from, "' does not exist on the list '").concat(listKey, "' as specified in the 'from' option of '").concat(listAndFieldPath, "'"));
        } // Ensure we generate on a complete object (because `resolvedData` may
        // only be partial)


        return generateSlug(_objectSpread$i({}, existingItem, {}, resolvedData)[from]);
      };
    } else if (!generate) {
      // Set a default `generate` method
      generateFn = _ref4 => {
        let {
          resolvedData,
          existingItem
        } = _ref4; // Ensure we generate on a complete object (because `resolvedData` may
        // only be partial)

        const _existingItem$resolve = _objectSpread$i({}, existingItem, {}, resolvedData),
              {
          id,
          name,
          title
        } = _existingItem$resolve,
              fields = _objectWithoutProperties(_existingItem$resolve, ["id", "name", "title"]);

        const valueToSlugify = name || title || findFirstNonEmptyStringValue(fields);

        if (!valueToSlugify) {
          throw new Error('Unable to find a valid field to generate a slug for ${listAndFieldPath}. Please provide a `generate` method.');
        }

        return generateSlug(valueToSlugify);
      };
    } else {
      if (typeof generate !== 'function') {
        throw new Error("The 'generate' option on ".concat(listAndFieldPath, " must be a function, but received ").concat(typeof generate));
      } // Wrap the provided generator function in an error handler


      generateFn = async _ref5 => {
        let {
          resolvedData,
          existingItem
        } = _ref5;
        const slug = await generate({
          resolvedData,
          existingItem
        });

        if (typeof slug !== 'string') {
          throw new Error("".concat(listAndFieldPath, "'s 'generate' option resolved with a ").concat(typeof slug, ", but expected a string."));
        }

        return slug;
      };
    }

    if (typeof makeUnique === 'undefined') {
      // Set the default uniqueifying function
      makeUniqueFn = _ref6 => {
        let {
          slug
        } = _ref6;
        return "".concat(slug, "-").concat(cuid.slug());
      };
    } else {
      if (typeof makeUnique !== 'function') {
        throw new Error("The 'makeUnique' option on ".concat(listAndFieldPath, " must be a function, but received ").concat(typeof makeUnique));
      } // Wrap the provided makeUnique function in an error handler


      makeUniqueFn = async _ref7 => {
        let {
          slug,
          previousSlug
        } = _ref7;
        const uniqueifiedSlug = await makeUnique({
          slug,
          previousSlug
        });

        if (typeof uniqueifiedSlug !== 'string') {
          throw new Error("".concat(listAndFieldPath, "'s 'makeUnique' option resolved with a ").concat(typeof uniqueifiedSlug, ", but expected a string."));
        }

        return uniqueifiedSlug;
      };
    }

    const isUniqueCalculated = typeof isUnique === 'undefined' ? true : isUnique;
    super(arguments[0], _objectSpread$i({}, arguments[1], {
      // Default isUnique to true
      isUnique: isUniqueCalculated
    }), arguments[2]);
    this.isUnique = isUniqueCalculated;
    this.generateFn = generateFn;
    this.makeUnique = makeUniqueFn;
    this.regenerateOnUpdate = regenerateOnUpdate;
    this.alwaysMakeUnique = alwaysMakeUnique;
    this.isOrderable = true;
  }

  async resolveInput(_ref8) {
    let {
      resolvedData,
      existingItem,
      actions: {
        query
      }
    } = _ref8;
    let slug; // A slug has been passed in

    if (resolvedData[this.path]) {
      // A slug was passed in, so we want to use that.
      // NOTE: This can result in slugs changing if doing an update and the
      // passed-in slug is not unique:
      // 1. Perform a `create` mutation: `createPost(data: { slug:
      //    "hello-world" }) { slug }`.
      //   * Result: `{ slug: "hello-world" }`
      // 2. Perform a second `create` mutation with the same slug: `createPost(data: { slug: "hello-world" }) { id slug }`.
      //   * Result (approximately): `{ id: "1", slug: "hello-world-weer84fs" }`
      // 3. Perform an update to the second item, with the same slug as the first (again): `updatePost(id: "1", data: { slug: "hello-world" }) { id slug }`.
      //   * Result (approximately): `{ id: "1", slug: "hello-world-uyi3lh32" }`
      //   * The slug has changed, even though we passed the same slug in.
      //     This happens because there is no way to know what the previously
      //     passed-in slug was, only the most recently _uniquified_ slug (ie;
      //     `"hello-world-weer84fs"`).
      slug = resolvedData[this.path];
    } else {
      // During a create
      if (!existingItem) {
        // We always generate a new one
        slug = await this.generateFn({
          resolvedData
        });
      } else {
        // During an update
        // There used to be a slug set, and we don't want to forcibly regenerate
        if (!this.regenerateOnUpdate) {
          // So we re-use that existing slug
          // Later, we check for uniqueness against other items, while excluding
          // this one, ensuring this slug stays stable.
          // NOTE: If a slug was not previously set, this _will not_ generate a
          // new one.
          slug = existingItem[this.path];
        } else {
          // Attempt to regenerate the raw slug (before it was passed through
          // `makeUnique`) from existing data
          const existingNonUniqueSlug = await this.generateFn({
            resolvedData: existingItem
          }); // Now generate the new raw slug (it has yet to be passed through
          // `makeUnique`)

          const newNonUniqueSlug = await this.generateFn({
            resolvedData,
            existingItem
          });

          if (existingNonUniqueSlug === newNonUniqueSlug) {
            // If they match, we can re-use the existing, unique slug. Note this
            // will still pass through uniquification, but because we only check
            // uniqueness against _other_ items, and this item already existed,
            // we can assume it will not need re-uniquifying, so passing it
            // through the logic below is ok.
            slug = existingItem[this.path];
          } else {
            // If they don't match, we have to assume some data important to the
            // slug has changed, so we go with the new value, and let it get
            // uniquified later
            slug = newNonUniqueSlug;
          }
        }
      }
    }

    if (!this.isUnique && !this.alwaysMakeUnique) {
      return slug;
    }

    let uniqueSlug = slug;
    let slugIsUnique;
    let makeUniqueAttempts = 0;
    const listAndFieldPath = "".concat(this.listKey, ".").concat(this.path); // The "all<List>s" query

    const {
      listQueryMetaName,
      whereInputName
    } = this.getListByKey(this.listKey).gqlNames; // A query to find any _other_ items with the same slug

    const queryString = "\n      query findDuplicate($where: ".concat(whereInputName, ") {\n        ").concat(listQueryMetaName, "(where: $where) {\n          count\n        }\n      }\n    ");

    if (this.alwaysMakeUnique) {
      // Force a uniquification pass over the slug
      uniqueSlug = await this.makeUnique({
        slug,
        previousSlug: uniqueSlug
      });
    } // Repeat until we have a unique slug, or we've tried too many times


    do {
      if (makeUniqueAttempts >= MAX_UNIQUE_ATTEMPTS) {
        throw new Error("Attempted to generate a unique slug for ".concat(listAndFieldPath, ", but failed after too many attempts. If you've passed a custom 'makeUnique' function, ensure it is working correctly"));
      }

      makeUniqueAttempts++; // Check to see if the slug is unique

      const {
        data,
        errors
      } = await query(queryString, {
        variables: {
          where: _objectSpread$i({
            [this.path]: uniqueSlug
          }, existingItem && existingItem.id && {
            id_not_in: [existingItem.id]
          })
        },
        // Access Control may filter out some results, so we wouldn't be
        // retreiving an accurate list of all existing items. Because we add the
        // unique constraint to the field, the database will throw an error if
        // we miss a match and try to insert anyway.
        skipAccessControl: true
      });

      if (errors) {
        throw new Error("Attempted to generate a unique slug for ".concat(listAndFieldPath, ", but failed with an error: ").concat(errors[0].toString()));
      }

      const duplicates = data[listQueryMetaName].count; // If there aren't any matches, this slug can be considered unique

      slugIsUnique = duplicates === 0;

      if (!slugIsUnique) {
        // An existinig slug was found, so we try make it unique
        uniqueSlug = await this.makeUnique({
          slug,
          previousSlug: uniqueSlug
        });
      }
    } while (!slugIsUnique);

    return uniqueSlug;
  }

}

const Slug = {
  type: 'Slug',
  implementation: SlugImplementation,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "1hkygzc"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    knex: KnexTextInterface,
    mongoose: MongoTextInterface
  }
};
var index$a = {
  type: 'Text',
  implementation: Text,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "1hkygzc"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$j(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$j(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$j(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$j(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

global.fetch = global.fetch || require('node-fetch');
const defaultTransforms = {
  fm: 'jpg',
  q: 75,
  fit: 'max'
};

function transformUserFromApiToKs5(user) {
  let {
    includeId = false
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread$j({}, includeId && {
    id: user.id
  }, {
    unsplashId: user.id,
    username: user.username,
    name: user.name,
    url: user.links.html,
    portfolioUrl: user.portfolio_url,
    bio: user.bio,
    location: user.location
  });
}

function transformImageFromApiToKs5(image) {
  let {
    includeId = false
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread$j({}, includeId && {
    id: image.id
  }, {
    unsplashId: image.id,
    width: image.width,
    height: image.height,
    color: image.color,
    description: image.description || null,
    alt: image.alt_description || null,
    publicUrl: image.urls.raw,
    user: transformUserFromApiToKs5(image.user, {
      includeId
    })
  });
}

class Unsplash extends Field {
  constructor(_, _ref) {
    let {
      accessKey,
      secretKey
    } = _ref;

    if (!accessKey) {
      throw new Error('Must provide an accessKey to Unsplash Image Field. See https://unsplash.com/documentation#creating-a-developer-account');
    }

    if (!secretKey) {
      throw new Error('Must provide a secretKey to Unsplash Image Field. See https://unsplash.com/documentation#creating-a-developer-account');
    }

    super(...arguments);
    this.graphQLOutputType = 'UnsplashImage';
    this.unsplash = new UnsplashAPI({
      applicationId: accessKey,
      secret: secretKey
    });
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.graphQLOutputType)];
  } // Filter based on Unsplash Image IDs


  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    return ["\n        # A stripped down set of information about an Unsplash User\n        # as returned from the Unsplash API\n        type UnsplashUser {\n          id: ID\n          unsplashId: String\n          username: String\n          name: String\n          # The user's URL on Unsplash\n          url: String\n          # The user supplied portfolio URL\n          portfolioUrl: String\n          bio: String\n          location: String\n        }\n      ", "\n        # Mirrors the formatting options [Unsplash provides](https://unsplash.com/documentation#dynamically-resizable-images).\n        # All options are strings as they ultimately end up in a URL.\n        input UnsplashImageFormat {\n          w: String\n          h: String\n          crop: String\n          # default: ".concat(defaultTransforms.fm, "\n          fm: String\n          auto: String\n          # default: ").concat(defaultTransforms.q, "\n          q: String\n          # default: ").concat(defaultTransforms.fit, "\n          fit: String\n          dpi: String\n        }\n      "), "\n        # Information describing an image as hosted by Unsplash\n        # NOTE: The public URLs returned here are Unsplash CDN URLs as per their terms:\n        # https://unsplash.com/api-terms\n        type ".concat(this.graphQLOutputType, " {\n          id: ID\n          unsplashId: String\n          width: Int\n          height: Int\n          color: String\n          # The author-supplied description of this photo\n          description: String\n          # A description of the photo for use with screen readers\n          alt: String\n          publicUrl: String\n          publicUrlTransformed(transformation: UnsplashImageFormat): String\n          user: UnsplashUser\n        }\n      "), "\n        enum UnsplashOrientation {\n          landscape\n          portrait\n          squarish\n        }\n      ", "\n        type UnsplashSearchResults {\n          total: Int\n          totalPages: Int\n          results: [".concat(this.graphQLOutputType, "]\n        }\n      ")];
  }

  getGqlAuxQueries() {
    return ["searchUnsplash(query: String!, page: Int, perPage: Int, orientation: UnsplashOrientation, collections: [String]): UnsplashSearchResults"];
  }

  gqlAuxQueryResolvers() {
    return {
      searchUnsplash: async (_, _ref2) => {
        let {
          query,
          page,
          perPage,
          orientation,
          collections
        } = _ref2;
        const {
          total,
          total_pages,
          results
        } = await this.unsplash.request({
          url: '/search/photos',
          method: 'GET',
          query: _objectSpread$j({
            query
          }, typeof page !== 'undefined' && {
            page
          }, {}, typeof perPage !== 'undefined' && {
            per_page: perPage
          }, {}, typeof orientation !== 'undefined' && {
            orientation
          }, {}, collections && collections.length && {
            collections: collections.join(',')
          })
        }).then(toJson);
        return {
          total,
          totalPages: total_pages,
          results: results.map(result => this.injectPublicUrlFields(transformImageFromApiToKs5(result, {
            includeId: true
          })))
        };
      }
    };
  }

  injectPublicUrlFields(data) {
    return _objectSpread$j({}, data, {
      // We want the default transformations applied to the regular public
      // URL, so we do a "transformation" here too
      publicUrl: this.publicUrlTransformed(data.publicUrl),
      publicUrlTransformed: _ref3 => {
        let {
          transformation
        } = _ref3;
        return this.publicUrlTransformed(data.publicUrl, transformation);
      }
    });
  }

  publicUrlTransformed(publicUrl, transformation) {
    const {
      url,
      query
    } = queryString.parseUrl(publicUrl);
    const transformationQueryString = queryString.stringify(_objectSpread$j({}, defaultTransforms, {}, transformation, {}, query));
    return "".concat(url).concat(transformationQueryString ? "?".concat(transformationQueryString) : '');
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        }

        return this.injectPublicUrlFields(itemValues);
      }
    };
  }

  async resolveInput(_ref4) {
    let {
      resolvedData
    } = _ref4;
    const inputId = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputId) return inputId`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof inputId === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (inputId === null) {
      // `null` was specifically uploaded, and we should set the field value to
      // null. To do that we... return `null`
      return null;
    }

    const apiResponse = await this.unsplash.photos.getPhoto(inputId).then(toJson); // NOTE: No need to await the response here, it's an event trigger for
    // Unsplash.

    this.unsplash.photos.downloadPhoto(apiResponse); // NOTE: we need to provide an id for the image to avoid issues with Apollo
    // More info here: https://github.com/keystonejs/keystone-5/pull/1799

    return transformImageFromApiToKs5(apiResponse, {
      includeId: true
    });
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": String")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": String")];
  }

}

const CommonUnsplashInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$j({}, this.equalityConditions(dbPath, _ref5 => {
      let {
        unsplashId
      } = _ref5;
      return unsplashId;
    }), {}, this.stringConditions(dbPath, _ref6 => {
      let {
        unsplashId
      } = _ref6;
      return unsplashId;
    }), {}, this.inConditions(dbPath, _ref7 => {
      let {
        unsplashId
      } = _ref7;
      return unsplashId;
    }));
  }

};

class MongoUnsplashInterface extends CommonUnsplashInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Object
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexUnsplashInterface extends CommonUnsplashInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw "The Unsplash field type doesn't support indexes on Knex. " + "Check the config for ".concat(this.path, " on the ").concat(this.field.listKey, " list");
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

function ownKeys$k(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$k(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$k(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$k(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const RelationshipWrapper$2 = _objectSpread$k({}, RelationshipType, {
  implementation: class extends RelationshipType.implementation {
    async resolveNestedOperations(operations, item, context) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      const result = await super.resolveNestedOperations(operations, item, context, ...args);
      context._blockMeta = context._blockMeta || {};
      context._blockMeta[this.listKey] = context._blockMeta[this.listKey] || {};
      context._blockMeta[this.listKey][this.path] = result;
      return result;
    }

  }
});

class UnsplashBlock extends Block {
  constructor(_ref, _ref2) {
    let {
      accessKey,
      secretKey,
      attribution
    } = _ref;
    let {
      fromList,
      joinList,
      createAuxList,
      getListByKey
    } = _ref2;
    super(...arguments);
    this.joinList = joinList;

    if (typeof attribution === 'string' && attribution) {
      this.attribution = {
        source: attribution
      };
    } else if (typeof attribution === 'object' && attribution.source) {
      this.attribution = attribution;
    } else {
      throw new Error('The unsplash-image block requires the `attribution` option to be either a string, or object { source<String>, medium<String?> }');
    }

    const auxListKey = "_Block_".concat(fromList, "_").concat(this.type); // Ensure the list is only instantiated once per server instance.

    let auxList = getListByKey(auxListKey);

    if (!auxList) {
      auxList = createAuxList(auxListKey, {
        fields: {
          image: {
            type: Unsplash$1,
            isRequired: true,
            accessKey,
            secretKey,
            schemaDoc: 'Unsplash image data'
          },
          // Useful for doing reverse lookups such as:
          // - "Get all embeds in this post"
          // - "List all users mentioned in comment"
          from: {
            type: RelationshipType,
            isRequired: true,
            ref: "".concat(joinList, ".").concat(this.path),
            schemaDoc: 'A reference back to the Slate.js Serialised Document this unsplash image is contained within'
          }
        }
      });
    }

    this.auxList = auxList;
  }

  get type() {
    return 'unsplashImage';
  }

  get path() {
    return pluralize.plural(this.type);
  }

  getFieldDefinitions() {
    return {
      [this.path]: {
        type: RelationshipWrapper$2,
        ref: "".concat(this.auxList.key, ".from"),
        many: true,
        schemaDoc: 'Unsplash Images which have been added to the Content field'
      }
    };
  }

  getMutationOperationResults(_ref3) {
    let {
      context
    } = _ref3;
    return {
      [this.path]: context._blockMeta && context._blockMeta[this.joinList] && context._blockMeta[this.joinList][this.path]
    };
  }

  getAdminViews() {
    return [_join(__dirname, "10cirgn")];
  }

  getViewOptions() {
    return {
      query: "\n        unsplashImages {\n          id\n          image {\n            id\n            unsplashId\n            publicUrl: publicUrlTransformed(transformation: { w: \"620\" })\n            description\n            user {\n              name\n              url\n            }\n          }\n        }\n      ",
      attribution: this.attribution
    };
  }

}

var Unsplash$1 = {
  type: 'Unsplash',
  implementation: Unsplash,
  views: {
    Controller: _join(__dirname, "1c59lz8"),
    Field: _join(__dirname, "1mjnj57"),
    Cell: _join(__dirname, "wmn1lu")
  },
  adapters: {
    mongoose: MongoUnsplashInterface,
    knex: KnexUnsplashInterface
  },
  blocks: {
    unsplashImage: UnsplashBlock
  }
};
var index$b = {
  type: 'Url',
  implementation: Text,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "os2npx"),
    Filter: _join(__dirname, "1603tj9"),
    Cell: _join(__dirname, "tzatfx")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$l(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$l(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$l(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$l(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class UuidImplementation extends Field {
  constructor(path, _ref) {
    let {
      caseTo = 'lower'
    } = _ref;
    super(...arguments);

    this.normaliseValue = a => a;

    if (caseTo && caseTo.toString().toLowerCase() === 'upper') {
      this.normaliseValue = a => a.toString().toUpperCase();
    } else if (caseTo && caseTo.toString().toLowerCase() === 'lower') {
      this.normaliseValue = a => a.toString().toLowerCase();
    }

    this.isOrderable = true;
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ID")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('ID'), ...this.inInputFields('ID')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": ID")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": ID")];
  }

}

const validator = a => typeof a === 'string' && /^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$/.test(a); // TODO: UUIDs _should_ be stored in Mongo using binary subtype 0x04 but strings are easier; see README.md


class MongoUuidInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema, mongoose) {
    const schemaOptions = {
      type: mongoose.Schema.Types.String,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not a valid UUID. Must be 8-4-4-4-12 hex format'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

  setupHooks(_ref2) {
    let {
      addPreSaveHook,
      addPostReadHook
    } = _ref2; // TODO: Remove the need to dereference the list and field to get the normalise function

    addPreSaveHook(item => {
      const valType = typeof item[this.path];

      if (item[this.path] && valType === 'string') {
        item[this.path] = this.field.normaliseValue(item[this.path]);
      } else if (!item[this.path] || valType === 'undefined') {
        delete item[this.path];
      } else {
        // Should have been caught by the validator??
        throw "Invalid UUID value given for '".concat(this.path, "'");
      }

      return item;
    });
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = this.field.normaliseValue(item[this.path]);
      }

      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread$l({}, this.equalityConditions(dbPath, this.field.normaliseValue), {}, this.inConditions(dbPath, this.field.normaliseValue));
  }

}

class KnexUuidInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments); // TODO: Warning on invalid config for primary keys?

    if (!this.field.isPrimaryKey) {
      this.isUnique = !!this.config.isUnique;
      this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
    }
  }

  addToTableSchema(table) {
    const column = table.uuid(this.path); // Fair to say primary keys are always non-nullable and uniqueness is implied by primary()

    if (this.field.isPrimaryKey) {
      column.primary().notNullable();
    } else {
      if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
      if (this.isNotNullable) column.notNullable();
    }

    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

  addToForeignTableSchema(table, _ref3) {
    let {
      path,
      isUnique,
      isIndexed,
      isNotNullable
    } = _ref3;

    if (!this.field.isPrimaryKey) {
      throw "Can't create foreign key '".concat(path, "' on table \"").concat(table._tableName, "\"; ") + "'".concat(this.path, "' on list '").concat(this.field.listKey, "' as is not the primary key.");
    }

    const column = table.uuid(path);
    if (isUnique) column.unique();else if (isIndexed) column.index();
    if (isNotNullable) column.notNullable();
  }

  getQueryConditions(dbPath) {
    return _objectSpread$l({}, this.equalityConditions(dbPath, this.field.normaliseValue), {}, this.inConditions(dbPath, this.field.normaliseValue));
  }

}

const Uuid = {
  type: 'Uuid',
  implementation: UuidImplementation,
  views: {
    Controller: _join(__dirname, "1qy9sro"),
    Field: _join(__dirname, "14e1hhi"),
    Filter: _join(__dirname, "13nbhhd")
  },
  adapters: {
    knex: KnexUuidInterface,
    mongoose: MongoUuidInterface
  },
  primaryKeyDefaults: {
    knex: {
      getConfig: client => {
        if (client === 'postgres') {
          return {
            type: Uuid,
            knexOptions: {
              defaultTo: knex => knex.raw('gen_random_uuid()')
            }
          };
        }

        throw "The Uuid field type doesn't provide a default primary key field configuration for the " + "'".concat(client, "' knex client. You'll need to supply your own 'id' field for each list or use a ") + "different field type for your ids (eg '@keystonejs/fields-auto-increment').";
      }
    },
    mongoose: {
      getConfig: () => {
        throw "The Uuid field type doesn't provide a default primary key field configuration for mongoose. " + "You'll need to supply your own 'id' field for each list or use a different field type for your " + "ids (eg '@keystonejs/fields-mongoid').";
      }
    }
  }
};

function ownKeys$m(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$m(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$m(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$m(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Virtual extends Field {
  constructor() {
    super(...arguments);
  }

  gqlOutputFields() {
    return ["".concat(this.path, ": ").concat(this.config.graphQLReturnType || "String")];
  }

  getGqlAuxTypes() {
    return this.config.extendGraphQLTypes || [];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: this.config.resolver
    };
  }

  gqlQueryInputFields() {
    return [];
  }

  extendAdminMeta(meta) {
    return _objectSpread$m({}, meta, {
      isOrderable: false,
      graphQLSelection: this.config.graphQLReturnFragment || '',
      isReadOnly: true
    });
  }

  parseFieldAccess(args) {
    const parsedAccess = parseFieldAccess(args);
    const fieldDefaults = {
      create: false,
      update: false,
      delete: false
    };
    return Object.keys(parsedAccess).reduce((prev, schemaName) => {
      prev[schemaName] = _objectSpread$m({}, fieldDefaults, {
        read: parsedAccess[schemaName].read
      });
      return prev;
    }, {});
  }

}

const CommonTextInterface$1 = superclass => class extends superclass {
  getQueryConditions() {
    return {};
  }

};

class MongoVirtualInterface extends CommonTextInterface$1(MongooseFieldAdapter) {
  addToMongooseSchema() {}

}

class KnexVirtualInterface extends CommonTextInterface$1(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.realKeys = [];
  }

  addToTableSchema() {}

}

var index$c = {
  type: 'Virtual',
  implementation: Virtual,
  views: {
    Controller: _join(__dirname, "1u1f5ml"),
    Cell: _join(__dirname, "im20a2"),
    Field: _join(__dirname, "1lbva73"),
    Filter: _join(__dirname, "1pjmpnt")
  },
  adapters: {
    mongoose: MongoVirtualInterface,
    knex: KnexVirtualInterface
  }
};
export { index as CalendarDay, index$1 as Checkbox, CloudinaryImage$1 as CloudinaryImage, index$2 as Color, index$3 as DateTime, index$4 as Decimal, index$5 as File, index$6 as Float, Field as Implementation, index$7 as Integer, index$8 as Location, OEmbed$1 as OEmbed, index$9 as Password, RelationshipType as Relationship, SelectType as Select, Slug, index$a as Text, Unsplash$1 as Unsplash, index$b as Url, Uuid, index$c as Virtual };
