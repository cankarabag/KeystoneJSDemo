import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import { FieldContainer, FieldLabel, FieldDescription, FieldInput } from '@arch-ui/fields';
import { Component } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import { gridSize, borderRadius, colors } from '@arch-ui/theme';
import { AlertIcon } from '@arch-ui/icons';
import { LoadingButton, Button } from '@arch-ui/button';
import PropTypes from 'prop-types';
import { HiddenInput } from '@arch-ui/input';
import { Lozenge } from '@arch-ui/lozenge';
import { FlexGroup } from '@arch-ui/layout';

function uploadButtonLabelFn(_ref) {
  let {
    status
  } = _ref;
  return status === 'empty' ? 'Upload Image' : 'Change Image';
}

function cancelButtonLabelFn(_ref2) {
  let {
    status
  } = _ref2;

  switch (status) {
    case 'stored':
      return 'Remove Image';

    case 'removed':
      return 'Undo Remove';

    case 'updated':
    default:
      return 'Cancel';
  }
}

function statusMessageFn(_ref3) {
  let {
    status
  } = _ref3;

  switch (status) {
    case 'removed':
      return 'save to remove';

    case 'updated':
      return 'save to upload';
  }
}

function errorMessageFn(_ref4) {
  let {
    type
  } = _ref4;

  switch (type) {
    case 'invalid':
      return 'Only image files are allowed. Please try again.';

    case 'save':
      return 'Something went wrong, please reload and try again.';

    case 'preview':
      return 'Something went wrong, please try again.';
  }
}

class FileField extends Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "onCancel", () => {
      // revert to the original file if available
      this.props.onChange(this.originalFile);
      this.setState({
        changeStatus: this.originalFile ? 'stored' : 'empty',
        dataURI: null,
        errorMessage: null
      });
    });

    _defineProperty(this, "onRemove", () => {
      this.setState({
        changeStatus: 'removed',
        errorMessage: null
      });
      this.props.onChange(null);
    });

    _defineProperty(this, "onChange", _ref5 => {
      let {
        target: {
          validity,
          files: [file]
        }
      } = _ref5;
      if (!file) return; // bail if the user cancels from the file browser

      const {
        errorMessage,
        onChange
      } = this.props; // basic validity check

      if (!validity.valid) {
        this.setState({
          errorMessage: errorMessage({
            type: 'save'
          })
        });
        return;
      } // check if the file is actually an image


      if (!file.type.includes('image')) {
        this.setState({
          errorMessage: errorMessage({
            type: 'invalid'
          })
        });
        return;
      } else if (this.state.errorMessage) {
        this.setState({
          errorMessage: null
        });
      }

      this.setState({
        changeStatus: 'updated',
        oldImagePath: this.getImagePath() // used during FileReader processing

      });
      onChange(file);
      this.getDataURI(file);
    });

    _defineProperty(this, "openFileBrowser", () => {
      if (this.inputRef) this.inputRef.click();
    });

    _defineProperty(this, "getFile", () => {
      const {
        value
      } = this.props;
      const {
        changeStatus
      } = this.state;
      const isRemoved = changeStatus === 'removed';
      const file = isRemoved ? this.originalFile : value;
      const type = file && file['__typename'] ? 'server' : 'client';
      return {
        file,
        type
      };
    });

    _defineProperty(this, "getDataURI", file => {
      const {
        errorMessage
      } = this.props;
      const reader = new FileReader();
      reader.readAsDataURL(file);

      reader.onloadstart = () => {
        this.setState({
          isLoading: true
        });
      };

      reader.onerror = err => {
        console.error('Error with Cloudinary preview', err);
        this.setState({
          errorMessage: errorMessage({
            type: 'preview'
          })
        });
      };

      reader.onloadend = upload => {
        this.setState({
          isLoading: false,
          dataURI: upload.target.result
        });
      };
    });

    _defineProperty(this, "getImagePath", () => {
      const {
        dataURI,
        oldImagePath
      } = this.state;
      const {
        file
      } = this.getFile(); // avoid jank during FileReader processing keeping the old image in place

      return file && file.publicUrlTransformed || dataURI || oldImagePath;
    });

    _defineProperty(this, "getInputRef", ref => {
      this.inputRef = ref;
    });

    _defineProperty(this, "renderUploadButton", () => {
      const {
        uploadButtonLabel
      } = this.props;
      const {
        changeStatus,
        isLoading
      } = this.state;
      return jsx(LoadingButton, {
        onClick: this.openFileBrowser,
        isLoading: isLoading,
        variant: "ghost"
      }, uploadButtonLabel({
        status: changeStatus
      }));
    });

    _defineProperty(this, "renderCancelButton", () => {
      const {
        cancelButtonLabel
      } = this.props;
      const {
        changeStatus
      } = this.state; // possible states; no case for 'empty' as cancel is not rendered

      let appearance = 'warning';
      let onClick = this.onRemove;

      switch (changeStatus) {
        case 'removed':
          appearance = 'primary';
          onClick = this.onCancel;
          break;

        case 'updated':
          onClick = this.onCancel;
          break;
      }

      return jsx(Button, {
        onClick: onClick,
        variant: "subtle",
        appearance: appearance
      }, cancelButtonLabel({
        status: changeStatus
      }));
    });

    const {
      value: _value
    } = props;
    this.originalFile = _value;

    const _changeStatus = this.originalFile ? 'stored' : 'empty';

    this.state = {
      changeStatus: _changeStatus,
      dataURI: null,
      errorMessage: null,
      isLoading: false,
      oldImagePath: null
    };
  } // ==============================
  // Change Handlers
  // ==============================


  render() {
    const {
      autoFocus,
      field,
      statusMessage,
      errors
    } = this.props;
    const {
      changeStatus,
      errorMessage
    } = this.state;
    const {
      file
    } = this.getFile();
    const imagePath = this.getImagePath();
    const showStatusMessage = ['removed', 'updated'].includes(changeStatus);
    const isEmpty = changeStatus === 'empty';
    const htmlID = "ks-input-".concat(field.path);
    return jsx(FieldContainer, null, jsx(FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), field.config.adminDoc && jsx(FieldDescription, null, field.config.adminDoc), jsx(FieldInput, null, !isEmpty && imagePath ? jsx(Wrapper, null, jsx(Image, {
      src: imagePath,
      alt: field.path
    }), jsx(Content, null, jsx(FlexGroup, {
      style: {
        marginBottom: gridSize
      }
    }, this.renderUploadButton(), this.renderCancelButton()), errorMessage ? jsx(ErrorInfo, null, errorMessage) : file ? jsx(FlexGroup, {
      isInline: true,
      growIndexes: [0]
    }, jsx(MetaInfo, null, file.filename || file.name), showStatusMessage ? jsx(ChangeInfo, {
      status: changeStatus
    }, statusMessage({
      status: changeStatus
    })) : null) : null)) : this.renderUploadButton(), jsx(HiddenInput, {
      autoComplete: "off",
      autoFocus: autoFocus,
      id: htmlID,
      innerRef: this.getInputRef,
      name: field.path,
      onChange: this.onChange,
      type: "file"
    })));
  }

} // ==============================
// Styled Components
// ==============================


_defineProperty(FileField, "propTypes", {
  cancelButtonLabel: PropTypes.func.isRequired,
  disabled: PropTypes.bool,
  errorMessage: PropTypes.func.isRequired,
  field: PropTypes.object,
  onChange: PropTypes.func.isRequired,
  statusMessage: PropTypes.func.isRequired,
  uploadButtonLabel: PropTypes.func.isRequired
});

_defineProperty(FileField, "defaultProps", {
  cancelButtonLabel: cancelButtonLabelFn,
  errorMessage: errorMessageFn,
  statusMessage: statusMessageFn,
  uploadButtonLabel: uploadButtonLabelFn
});

const Wrapper = props => jsx("div", _extends({
  css: {
    alignItems: 'flex-start',
    display: 'flex'
  }
}, props));

const Content = props => jsx("div", _extends({
  css: {
    flex: 1,
    minWidth: 0
  }
}, props));

const Image = props => jsx("div", {
  css: {
    backgroundColor: 'white',
    borderRadius,
    border: "1px solid ".concat(colors.N20),
    flexShrink: 0,
    lineHeight: 0,
    marginRight: gridSize,
    padding: 4,
    position: 'relative',
    textAlign: 'center',
    width: 130 // 120px image + chrome

  }
}, jsx("img", _extends({
  css: {
    height: 'auto',
    maxWidth: '100%'
  }
}, props)));

const MetaInfo = props => jsx(Lozenge, _extends({
  crop: "right"
}, props));

const ErrorInfo = _ref6 => {
  let {
    children
  } = _ref6,
      props = _objectWithoutProperties(_ref6, ["children"]);

  return jsx(Lozenge, _extends({
    style: {
      backgroundColor: colors.R.L80,
      borderColor: 'transparent',
      color: colors.R.D20,
      display: 'inline-flex'
    }
  }, props), jsx(AlertIcon, {
    css: {
      marginRight: gridSize
    }
  }), children);
};

const appearanceMap = {
  default: 'primary',
  removed: 'danger',
  updated: 'create'
};

const ChangeInfo = _ref7 => {
  let {
    status = 'default'
  } = _ref7,
      props = _objectWithoutProperties(_ref7, ["status"]);

  const appearance = appearanceMap[status];
  return jsx(Lozenge, _extends({
    appearance: appearance
  }, props));
};

export default FileField;
