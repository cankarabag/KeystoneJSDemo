import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import '@babel/runtime/helpers/esm/objectWithoutProperties';
import pluralize from 'pluralize';
import { jsx } from '@emotion/core';
import { createContext, useState, Suspense, Fragment, useContext } from 'react';
import '@babel/runtime/helpers/esm/extends';
import { Button } from '@arch-ui/button';
import { BlockMenuItem } from '@keystonejs/field-content/block-components';
import { P as Preview } from './preview-7a621635.esm.js';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

let type = 'oEmbed'; // TODO: Receive this value from the server somehow. 'pluralize' is a fairly
// large lib.

const path = pluralize.plural(type);
let Context = createContext(null);
let Provider = Context.Provider;

const Embed = _ref => {
  let {
    url,
    oembedData
  } = _ref;
  let options = useContext(Context);

  if (options.previewComponent) {
    // The adapter should implement this option
    const [Preview] = options.adminMeta.readViews([options.previewComponent]);
    return jsx(Preview, {
      url: url,
      options: options
    });
  } else {
    // This is a fallback so we can at least try to render _something_
    return jsx(Preview, {
      data: oembedData,
      originalUrl: url
    });
  }
};

let Block = _ref2 => {
  let {
    url,
    oembedData,
    onChange,
    onRemove
  } = _ref2;
  let [currentValue, setCurrentValue] = useState(url);
  let embed = null;

  if (url) {
    embed = jsx(Suspense, {
      fallback: jsx("div", null, "Generating Preview...")
    }, jsx(Embed, {
      url: url,
      oembedData: oembedData
    }));
  }

  return jsx(Fragment, null, jsx("form", {
    onSubmit: e => {
      e.preventDefault();
      onChange(currentValue);
    }
  }, jsx("div", {
    css: {
      width: '100%',
      display: 'flex'
    }
  }, jsx("input", {
    type: "url",
    placeholder: "Enter a URL and press enter to add an embed",
    css: {
      flex: 10,
      display: 'inline',
      border: 'none',
      backgroundColor: 'transparent',
      outline: 'none',
      paddingTop: 8,
      paddingBottom: 8,
      fontSize: 18
    },
    onClick: e => {
      e.stopPropagation();
    },
    value: currentValue,
    onChange: e => {
      setCurrentValue(e.target.value);
    }
  }), jsx("div", {
    css: {
      display: 'inline-flex',
      alignItems: 'center',
      padding: 8
    }
  }, jsx(Button, {
    appearance: "danger",
    onClick: onRemove,
    type: "button"
  }, "Remove")))), embed);
};

function Sidebar(_ref3) {
  let {
    editor
  } = _ref3;
  const icon = jsx("svg", {
    width: 16,
    height: 16,
    ariaHidden: "true",
    focusable: "false",
    role: "img",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 384 512"
  }, jsx("path", {
    d: "M320,32a32,32,0,0,0-64,0v96h64Zm48,128H16A16,16,0,0,0,0,176v32a16,16,0,0,0,16,16H32v32A160.07,160.07,0,0,0,160,412.8V512h64V412.8A160.07,160.07,0,0,0,352,256V224h16a16,16,0,0,0,16-16V176A16,16,0,0,0,368,160ZM128,32a32,32,0,0,0-64,0v96h64Z"
  }));
  return jsx(BlockMenuItem, {
    icon: icon,
    text: "Embed",
    insertBlock: () => {
      editor.insertBlock({
        type
      });
    }
  });
}

function Node(_ref4) {
  let {
    node,
    editor
  } = _ref4;
  return jsx(Block, {
    url: node.data.get('url'),
    oembedData: node.data.get('oembedData'),
    onRemove: () => {
      editor.removeNodeByKey(node.key);
    },
    onChange: url => {
      editor.setNodeByKey(node.key, {
        data: node.data.set('url', url)
      });
    }
  });
}

let getSchema = () => ({
  isVoid: true
});

function serialize(_ref5) {
  let {
    node
  } = _ref5;
  const url = node.data.get('url');
  const joinIds = node.data.get('_joinIds');
  const mutations = joinIds && joinIds.length ? {
    connect: {
      id: joinIds[0]
    }
  } : {
    create: {
      embed: url
    }
  };
  return {
    mutations,
    node: _objectSpread({}, node.toJSON(), {
      // Zero out the data so we don't unnecesarily duplicate the url
      data: {}
    })
  };
}

function deserialize(_ref6) {
  let {
    node,
    joins
  } = _ref6;

  if (!joins || !Array.isArray(joins) || joins.length === 0 || !joins[0].embed) {
    console.error('No embed data received when rehydrating oEmbed block');
    return;
  } // Inject the original url back into the block


  return node.set('data', node.data.set('url', joins[0].embed.originalUrl).set('oembedData', joins[0].embed));
}

export { Node, Provider, Sidebar, deserialize, getSchema, path, serialize, type };
