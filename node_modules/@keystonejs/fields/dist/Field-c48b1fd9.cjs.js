'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var core = require('@emotion/core');

var fields = require('@arch-ui/fields');

var React = require('react');

var React__default = _interopDefault(React);

var _extends = _interopDefault(require("@babel/runtime/helpers/extends"));

var theme = require('@arch-ui/theme');

var icons = require('@arch-ui/icons');

var button = require('@arch-ui/button');

var PropTypes = _interopDefault(require('prop-types'));

var input = require('@arch-ui/input');

var lozenge = require('@arch-ui/lozenge');

var layout = require('@arch-ui/layout');

function uploadButtonLabelFn(_ref) {
  let {
    status
  } = _ref;
  return status === 'empty' ? 'Upload File' : 'Change File';
}

function cancelButtonLabelFn(_ref2) {
  let {
    status
  } = _ref2;

  switch (status) {
    case 'stored':
      return 'Remove File';

    case 'removed':
      return 'Undo Remove';

    case 'updated':
    default:
      return 'Cancel';
  }
}

function statusMessageFn(_ref3) {
  let {
    status
  } = _ref3;

  switch (status) {
    case 'removed':
      return 'save to remove';

    case 'updated':
      return 'save to upload';
  }
}

function errorMessageFn(_ref4) {
  let {
    type
  } = _ref4;

  switch (type) {
    case 'save':
      return 'Something went wrong, please reload and try again.';

    case 'preview':
      return 'Something went wrong, please try again.';
  }
}

class FileField extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "onCancel", () => {
      // revert to the original file if available
      this.props.onChange(this.originalFile);
      this.setState({
        changeStatus: this.originalFile ? 'stored' : 'empty',
        dataURI: null,
        errorMessage: null
      });
    });

    _defineProperty(this, "onRemove", () => {
      this.setState({
        changeStatus: 'removed',
        errorMessage: null
      });
      this.props.onChange(null);
    });

    _defineProperty(this, "onChange", _ref5 => {
      let {
        target: {
          validity,
          files: [file]
        }
      } = _ref5;
      if (!file) return; // bail if the user cancels from the file browser

      const {
        errorMessage,
        onChange
      } = this.props;
      const newState = {
        changeStatus: 'updated'
      }; // basic validity check

      if (!validity.valid) {
        this.setState({
          errorMessage: errorMessage({
            type: 'save'
          })
        });
        return;
      } // resolve data URI for images


      if (file.type.includes('image')) {
        this.getDataURI(file);
        newState.oldImagePath = this.getImagePath(); // used during FileReader processing
      } else if (this.state.dataURI) {
        this.setState({
          dataURI: null,
          errorMessage: null
        });
      }

      onChange(file);
      this.setState(newState);
    });

    _defineProperty(this, "openFileBrowser", () => {
      if (this.inputRef) this.inputRef.click();
    });

    _defineProperty(this, "getFile", () => {
      const {
        value
      } = this.props;
      const {
        changeStatus
      } = this.state;
      const isRemoved = changeStatus === 'removed';
      const file = isRemoved ? this.originalFile : value;
      const type = file && file['__typename'] ? 'server' : 'client';
      return {
        file,
        type
      };
    });

    _defineProperty(this, "getDataURI", file => {
      const {
        errorMessage
      } = this.props;
      const reader = new FileReader();
      reader.readAsDataURL(file);

      reader.onloadstart = () => {
        this.setState({
          isLoading: true
        });
      };

      reader.onerror = err => {
        console.error('Error with Cloudinary preview', err);
        this.setState({
          errorMessage: errorMessage({
            type: 'preview'
          })
        });
      };

      reader.onloadend = upload => {
        this.setState({
          isLoading: false,
          dataURI: upload.target.result
        });
      };
    });

    _defineProperty(this, "getImagePath", () => {
      const {
        dataURI
      } = this.state;
      const {
        file
      } = this.getFile(); // avoid jank during FileReader processing keeping the old image in place

      return file && file.mimetype && file.mimetype.includes('image') ? file.publicUrl : dataURI;
    });

    _defineProperty(this, "getInputRef", ref => {
      this.inputRef = ref;
    });

    _defineProperty(this, "renderUploadButton", () => {
      const {
        uploadButtonLabel
      } = this.props;
      const {
        changeStatus,
        isLoading
      } = this.state;
      return core.jsx(button.LoadingButton, {
        onClick: this.openFileBrowser,
        isLoading: isLoading,
        variant: "ghost"
      }, uploadButtonLabel({
        status: changeStatus
      }));
    });

    _defineProperty(this, "renderCancelButton", () => {
      const {
        cancelButtonLabel
      } = this.props;
      const {
        changeStatus
      } = this.state; // possible states; no case for 'empty' as cancel is not rendered

      let appearance = 'warning';
      let onClick = this.onRemove;

      switch (changeStatus) {
        case 'removed':
          appearance = 'primary';
          onClick = this.onCancel;
          break;

        case 'updated':
          onClick = this.onCancel;
          break;
      }

      return core.jsx(button.Button, {
        onClick: onClick,
        variant: "subtle",
        appearance: appearance
      }, cancelButtonLabel({
        status: changeStatus
      }));
    });

    const {
      value: _value
    } = props;
    this.originalFile = _value;

    const _changeStatus = this.originalFile ? 'stored' : 'empty';

    this.state = {
      changeStatus: _changeStatus,
      dataURI: null,
      errorMessage: null,
      isLoading: false,
      oldImagePath: null
    };
  } // ==============================
  // Change Handlers
  // ==============================


  render() {
    const {
      autoFocus,
      field,
      statusMessage,
      errors
    } = this.props;
    const {
      changeStatus,
      errorMessage
    } = this.state;
    const {
      file
    } = this.getFile();
    const imagePath = this.getImagePath();
    const showStatusMessage = ['removed', 'updated'].includes(changeStatus);
    const htmlID = "ks-input-".concat(field.path);
    return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), field.config.adminDoc && core.jsx(fields.FieldDescription, null, field.config.adminDoc), core.jsx(fields.FieldInput, null, file ? core.jsx(Wrapper, null, imagePath ? core.jsx(Image, {
      src: imagePath,
      alt: field.path
    }) : null, core.jsx(Content, null, core.jsx(layout.FlexGroup, {
      style: {
        marginBottom: theme.gridSize
      }
    }, this.renderUploadButton(), this.renderCancelButton()), errorMessage ? core.jsx(ErrorInfo, null, errorMessage) : core.jsx(layout.FlexGroup, {
      isInline: true,
      growIndexes: [0]
    }, core.jsx(MetaInfo, {
      href: file.publicUrl
    }, file.filename || file.name), showStatusMessage ? core.jsx(ChangeInfo, {
      status: changeStatus
    }, statusMessage({
      status: changeStatus
    })) : null))) : this.renderUploadButton(), core.jsx(input.HiddenInput, {
      autoComplete: "off",
      autoFocus: autoFocus,
      id: htmlID,
      innerRef: this.getInputRef,
      name: field.path,
      onChange: this.onChange,
      type: "file"
    })));
  }

} // ==============================
// Styled Components
// ==============================


_defineProperty(FileField, "propTypes", {
  cancelButtonLabel: PropTypes.func.isRequired,
  disabled: PropTypes.bool,
  errorMessage: PropTypes.func.isRequired,
  field: PropTypes.object,
  onChange: PropTypes.func.isRequired,
  statusMessage: PropTypes.func.isRequired,
  uploadButtonLabel: PropTypes.func.isRequired
});

_defineProperty(FileField, "defaultProps", {
  cancelButtonLabel: cancelButtonLabelFn,
  errorMessage: errorMessageFn,
  statusMessage: statusMessageFn,
  uploadButtonLabel: uploadButtonLabelFn
});

const Wrapper = props => core.jsx("div", _extends({
  css: {
    alignItems: 'flex-start',
    display: 'flex'
  }
}, props));

const Content = props => core.jsx("div", _extends({
  css: {
    flex: 1,
    minWidth: 0
  }
}, props));

const Image = props => core.jsx("div", {
  css: {
    backgroundColor: 'white',
    borderRadius: theme.borderRadius,
    border: "1px solid ".concat(theme.colors.N20),
    flexShrink: 0,
    lineHeight: 0,
    marginRight: theme.gridSize,
    padding: 4,
    position: 'relative',
    textAlign: 'center',
    width: 130 // 120px image + chrome

  }
}, core.jsx("img", _extends({
  css: {
    height: 'auto',
    maxWidth: '100%'
  }
}, props)));

const MetaInfo = props => core.jsx(lozenge.Lozenge, _extends({
  crop: "right"
}, props));

const ErrorInfo = _ref6 => {
  let {
    children
  } = _ref6,
      props = _objectWithoutProperties(_ref6, ["children"]);

  return core.jsx(lozenge.Lozenge, _extends({
    style: {
      backgroundColor: theme.colors.R.L80,
      borderColor: 'transparent',
      color: theme.colors.R.D20,
      display: 'inline-flex'
    }
  }, props), core.jsx(icons.AlertIcon, {
    css: {
      marginRight: theme.gridSize
    }
  }), children);
};

const appearanceMap = {
  default: 'primary',
  removed: 'danger',
  updated: 'create'
};

const ChangeInfo = _ref7 => {
  let {
    status = 'default'
  } = _ref7,
      props = _objectWithoutProperties(_ref7, ["status"]);

  const appearance = appearanceMap[status];
  return core.jsx(lozenge.Lozenge, _extends({
    appearance: appearance
  }, props));
};

exports.default = FileField;
