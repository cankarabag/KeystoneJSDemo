import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import { FieldContainer, FieldLabel, FieldDescription, FieldInput } from '@arch-ui/fields';
import { Component, Fragment } from 'react';
import '@babel/runtime/helpers/esm/extends';
import '@arch-ui/select';
import { gridSize } from '@arch-ui/theme';
import _taggedTemplateLiteral from '@babel/runtime/helpers/esm/taggedTemplateLiteral';
import { useQuery } from '@apollo/react-hooks';
import gql from 'graphql-tag';
import { PersonIcon, LinkExternalIcon, PlusIcon } from '@arch-ui/icons';
import { IconButton } from '@arch-ui/button';
import Tooltip from '@arch-ui/tooltip';
import 'react-select';
import 'intersection-observer';
import { R as RelationshipSelect } from './RelationshipSelect-a88b22e2.esm.js';
import { ListProvider, useList } from '@keystonejs/app-admin-ui/components';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n    query User {\n      ", " {\n        _label_\n        id\n      }\n    }\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

const MAX_IDS_IN_FILTER = 100;

function SetAsCurrentUser(_ref) {
  let {
    listKey,
    value,
    onAddUser,
    many
  } = _ref;
  const path = 'authenticated' + listKey;
  const {
    data
  } = useQuery(gql(_templateObject(), path));

  if (data && data[path]) {
    const userId = data[path].id;

    if (value !== null && (many ? value.some(item => item.id === userId) : value.id === userId)) {
      return null;
    }

    const label = "".concat(many ? 'Add' : 'Set as', " ").concat(data[path]._label_);
    return jsx(Tooltip, {
      placement: "top",
      content: label
    }, ref => jsx(IconButton, {
      css: {
        marginLeft: gridSize
      },
      variant: "ghost",
      ref: ref,
      onClick: () => {
        onAddUser(data[path]);
      },
      icon: PersonIcon,
      "aria-label": label
    }));
  }

  return null;
}

function LinkToRelatedItems(_ref2) {
  let {
    field,
    value
  } = _ref2;
  const {
    many,
    ref
  } = field.config;
  const {
    adminPath,
    getListByKey
  } = field.adminMeta;
  const refList = getListByKey(ref);
  let isDisabled = false;
  let label;
  let link = "".concat(adminPath, "/").concat(refList.path);

  if (many) {
    label = 'View List of Related Items';

    if (!value.length) {
      isDisabled = true;
    } // What happens when there are 10,000 ids? The URL would be too
    // big, so we arbitrarily limit it to the first 100


    link = "".concat(link, "?!id_in=\"").concat(value.slice(0, MAX_IDS_IN_FILTER).map(_ref3 => {
      let {
        id
      } = _ref3;
      return id;
    }).join(','), "\"");
  } else {
    label = 'View Item Details';

    if (!value) {
      isDisabled = true;
    } else {
      link = "".concat(link, "/").concat(value.id);
    }
  }

  return jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => jsx(IconButton, {
    ref: ref,
    icon: LinkExternalIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: gridSize
    },
    target: "_blank",
    to: link,
    isDisabled: isDisabled
  }));
}

function CreateAndAddItem(_ref4) {
  let {
    field,
    item,
    onCreate: _onCreate,
    CreateItemModal
  } = _ref4;
  const {
    list,
    openCreateItemModal
  } = useList();
  let relatedList = field.adminMeta.getListByKey(field.config.ref);
  let label = "Create and add ".concat(relatedList.singular);
  let prefillData;

  if (item && item.id) {
    prefillData = relatedList.fields // Find relationships on the refList which have a back link to this
    // Relationship field
    .filter(relatedField => relatedField.type === 'Relationship' && relatedField.config.ref === list.key && relatedField.config.refFieldPath === field.path) // And convert it into an object of data to prefill the form with
    .reduce((memo, prefillField) => {
      const prefill = {
        _label_: item._label_ || '<link to parent>',
        id: item.id
      };
      return _objectSpread({}, memo, {
        [prefillField.path]: prefillField.config.many ? [prefill] : prefill
      });
    }, {});
  }

  return jsx(Fragment, null, jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => {
    return jsx(IconButton, {
      ref: ref,
      onClick: openCreateItemModal,
      icon: PlusIcon,
      "aria-label": label,
      variant: "ghost",
      css: {
        marginLeft: gridSize
      }
    });
  }), jsx(CreateItemModal, {
    prefillData: prefillData,
    onCreate: _ref5 => {
      let {
        data
      } = _ref5;

      _onCreate(data[relatedList.gqlNames.createMutationName]);
    }
  }));
}

class RelationshipField extends Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onChange", option => {
      const {
        field,
        onChange
      } = this.props;
      const {
        many
      } = field.config;

      if (many) {
        onChange(option ? option.map(i => i.value) : []);
      } else {
        onChange(option ? option.value : null);
      }
    });
  }

  render() {
    const {
      autoFocus,
      field,
      value,
      renderContext,
      errors,
      onChange,
      item,
      list,
      CreateItemModal
    } = this.props;
    const {
      many,
      ref
    } = field.config;
    const {
      authStrategy
    } = field.adminMeta;
    const htmlID = "ks-input-".concat(field.path);
    const relatedList = field.adminMeta.getListByKey(field.config.ref);
    return jsx(FieldContainer, null, jsx(FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), field.config.adminDoc && jsx(FieldDescription, null, field.config.adminDoc), jsx(FieldInput, null, jsx("div", {
      css: {
        flex: 1
      }
    }, jsx(RelationshipSelect, {
      autoFocus: autoFocus,
      isMulti: many,
      field: field,
      value: value,
      errors: errors,
      renderContext: renderContext,
      htmlID: htmlID,
      onChange: this.onChange
    })), jsx(ListProvider, {
      list: relatedList
    }, jsx(CreateAndAddItem, {
      onCreate: item => {
        onChange(many ? (value || []).concat(item) : item);
      },
      field: field,
      item: item,
      list: list,
      CreateItemModal: CreateItemModal
    })), authStrategy && ref === authStrategy.listKey && jsx(SetAsCurrentUser, {
      many: many,
      onAddUser: user => {
        onChange(many ? (value || []).concat(user) : user);
      },
      value: value,
      listKey: authStrategy.listKey
    }), jsx(LinkToRelatedItems, {
      field: field,
      value: value
    })));
  }

}

export default RelationshipField;
