'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var core = require('@emotion/core');

var fields = require('@arch-ui/fields');

var React = require('react');

var React__default = _interopDefault(React);

var _extends = _interopDefault(require("@babel/runtime/helpers/extends"));

var Select = _interopDefault(require('@arch-ui/select'));

var reactToastNotifications = require('react-toast-notifications');

var googleMapsReact = require('google-maps-react');

const LocationField = _ref => {
  let {
    field,
    value: serverValue,
    errors,
    onChange,
    google,
    renderContext
  } = _ref;
  const {
    googlePlaceID,
    formattedAddress,
    lat,
    lng
  } = serverValue || {};
  const htmlID = "ks-input-".concat(field.path);
  const autocompleteService = new google.maps.places.AutocompleteService();
  const geocoder = new google.maps.Geocoder();
  const {
    addToast
  } = reactToastNotifications.useToasts();
  const [inputValue, setInputValue] = React.useState(googlePlaceID ? {
    label: formattedAddress,
    value: googlePlaceID
  } : null);
  const [marker, setMarker] = React.useState(lat && lng ? {
    lat,
    lng
  } : null);

  const handleOptionChange = option => {
    if (!option) {
      onChange(null);
      setMarker(null);
      setInputValue(null);
      return;
    }

    const placeId = option.value;
    geocoder.geocode({
      placeId
    }, (results, status) => {
      if (status === 'OK') {
        if (results[0]) {
          const {
            formatted_address,
            geometry: {
              location: {
                lat,
                lng
              }
            }
          } = results[0];
          setInputValue({
            label: formatted_address,
            value: placeId
          });
          setMarker({
            lat: lat(),
            lng: lng()
          });
          onChange(placeId);
        }
      } else {
        addToast('Could not find the provided location.', {
          appearance: 'error',
          autoDismiss: true
        });
      }
    });
  };

  const loadOptions = inputValue => new Promise(resolve => {
    autocompleteService.getPlacePredictions({
      input: inputValue
    }, results => {
      if (results) {
        resolve(results.map(_ref2 => {
          let {
            description,
            place_id
          } = _ref2;
          return {
            label: description,
            value: place_id
          };
        }));
      }

      resolve(null);
    });
  });

  const selectProps = renderContext === 'dialog' ? {
    menuPortalTarget: document.body,
    menuShouldBlockScroll: true
  } : null;
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), field.config.adminDoc && core.jsx(fields.FieldDescription, null, field.config.adminDoc), core.jsx(fields.FieldInput, {
    css: {
      flexDirection: 'column'
    }
  }, core.jsx(Select, _extends({
    isAsync: true,
    isClearable: true,
    cacheOptions: true,
    placeholder: "Search for a location ...",
    value: inputValue,
    onChange: handleOptionChange,
    loadOptions: loadOptions,
    id: "react-select-".concat(htmlID),
    inputId: htmlID,
    instanceId: htmlID,
    css: {
      width: '100%'
    }
  }, selectProps)), marker && core.jsx("div", {
    css: {
      position: 'relative',
      height: '14rem',
      marginTop: '1rem'
    }
  }, core.jsx(googleMapsReact.Map, {
    google: google,
    initialCenter: marker,
    center: marker,
    zoom: 16
  }, core.jsx(googleMapsReact.Marker, {
    position: marker
  })))));
};

var Field = googleMapsReact.GoogleApiWrapper(props => ({
  apiKey: props.field.config.googleMapsKey
}))(LocationField);
exports.default = Field;
