import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import { forwardRef, useMemo, useRef, useState, useEffect } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import Select from '@arch-ui/select';
import _taggedTemplateLiteral from '@babel/runtime/helpers/esm/taggedTemplateLiteral';
import { useQuery } from '@apollo/react-hooks';
import gql from 'graphql-tag';
import { components } from 'react-select';
import 'intersection-observer';

function _templateObject2() {
  const data = _taggedTemplateLiteral(["query RelationshipSelect($search: String!, $skip: Int!) {", "", "}"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["query RelationshipSelectMore($search: String!, $skip: Int!) {", "}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function useIntersectionObserver(cb, ref) {
  useEffect(() => {
    let observer = new IntersectionObserver(cb, {});
    let node = ref.current;

    if (node !== null) {
      observer.observe(node);
      return () => observer.unobserve(node);
    }
  });
}

const initalItemsToLoad = 10;
const subsequentItemsToLoad = 50; // to use hooks in render props

const Relationship = forwardRef((_ref, ref) => {
  let {
    data,
    loading,
    value,
    refList,
    canRead,
    isMulti,
    search,
    autoFocus,
    serverErrors,
    onChange,
    htmlID,
    setSearch,
    selectProps,
    fetchMore
  } = _ref;
  const options = data && data[refList.gqlNames.listQueryName] ? data[refList.gqlNames.listQueryName].map(val => ({
    value: val,
    label: val._label_
  })) : [];
  const serverError = serverErrors && serverErrors.find(error => error instanceof Error && error.name === 'AccessDeniedError');
  let currentValue = null;

  const getOption = value => typeof value === 'string' ? options.find(opt => opt.value.id === value) || {
    label: value,
    value: value
  } : {
    label: value._label_,
    value: value
  };

  if (value !== null && canRead) {
    if (isMulti) {
      currentValue = (Array.isArray(value) ? value : []).map(getOption);
    } else if (value) {
      currentValue = getOption(value);
    }
  }

  const count = data && data[refList.gqlNames.listQueryMetaName] ? data[refList.gqlNames.listQueryMetaName].count : 0;
  const selectComponents = useMemo(() => ({
    MenuList: _ref2 => {
      let {
        children
      } = _ref2,
          props = _objectWithoutProperties(_ref2, ["children"]);

      const loadingRef = useRef(null);
      useIntersectionObserver(_ref3 => {
        let [{
          isIntersecting
        }] = _ref3;

        if (!props.isLoading && isIntersecting && props.options.length < count) {
          fetchMore({
            query: gql(_templateObject(), refList.buildQuery(refList.gqlNames.listQueryName, "(first: ".concat(subsequentItemsToLoad, ", search: $search, skip: $skip)"))),
            variables: {
              search,
              skip: props.options.length
            },
            updateQuery: (prev, _ref4) => {
              let {
                fetchMoreResult
              } = _ref4;
              if (!fetchMoreResult) return prev;
              return _objectSpread({}, prev, {
                [refList.gqlNames.listQueryName]: [...prev[refList.gqlNames.listQueryName], ...fetchMoreResult[refList.gqlNames.listQueryName]]
              });
            }
          });
        }
      }, loadingRef);
      return jsx(components.MenuList, props, children, jsx("div", {
        css: {
          textAlign: 'center'
        },
        ref: loadingRef
      }, props.options.length < count && jsx("span", {
        css: {
          padding: 8
        }
      }, "Loading...")));
    }
  }), [count, refList.gqlNames.listQueryName]);
  return jsx(Select // this is necessary because react-select passes a second argument to onInputChange
  // and useState setters log a warning if a second argument is passed
  , _extends({
    onInputChange: val => setSearch(val),
    isLoading: loading,
    autoFocus: autoFocus,
    isMulti: isMulti,
    components: selectComponents,
    getOptionValue: option => option.value.id,
    value: currentValue,
    placeholder: canRead ? undefined : serverError && serverError.message,
    options: options,
    onChange: onChange,
    id: "react-select-".concat(htmlID),
    isClearable: true,
    instanceId: htmlID,
    inputId: htmlID,
    innerRef: ref,
    menuPortalTarget: document.body
  }, selectProps));
});

const RelationshipSelect = _ref5 => {
  let {
    innerRef,
    autoFocus,
    field,
    errors: serverErrors,
    renderContext,
    htmlID,
    onChange,
    isMulti,
    value
  } = _ref5;
  const [search, setSearch] = useState('');
  const refList = field.getRefList();
  const query = gql(_templateObject2(), refList.buildQuery(refList.gqlNames.listQueryName, "(first: ".concat(initalItemsToLoad, ", search: $search, skip: $skip)")), refList.countQuery("(search: $search)"));
  const canRead = !serverErrors || serverErrors.every(error => !(error instanceof Error && error.name === 'AccessDeniedError'));
  const selectProps = renderContext === 'dialog' ? {
    menuShouldBlockScroll: true
  } : null;
  const {
    data,
    error,
    loading,
    fetchMore
  } = useQuery(query, {
    variables: {
      search,
      skip: 0
    }
  }); // TODO: better error UI
  // TODO: Handle permission errors
  // (ie; user has permission to read this relationship field, but
  // not the related list, or some items on the list)

  if (error) {
    console.log('ERROR!!!', error);
    return 'Error';
  }

  return jsx(Relationship, {
    data,
    loading,
    value,
    refList,
    canRead,
    isMulti,
    search,
    autoFocus,
    serverErrors,
    onChange,
    htmlID,
    setSearch,
    selectProps,
    fetchMore,
    ref: innerRef
  });
};

export { RelationshipSelect as R };
