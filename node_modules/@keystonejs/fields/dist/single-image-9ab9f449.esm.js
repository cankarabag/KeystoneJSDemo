import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import pluralize from 'pluralize';
import { jsx } from '@emotion/core';
import { useMemo } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import insertImages from 'slate-drop-or-paste-images';
import imageExtensions from 'image-extensions';
import { findNode } from 'slate-react';
import { Block, Data } from 'slate';
import { BlockMenuItem } from '@keystonejs/field-content/block-components';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const type = 'cloudinaryImage'; // TODO: Receive this value from the server somehow. 'pluralize' is a fairly
// large lib.

const path = pluralize.plural(type);

let getFiles = () => new Promise(resolve => {
  let input = document.createElement('input');
  input.type = 'file';

  input.onchange = () => resolve([...input.files]);

  input.click();
});

const insertImageBlockFromFile = (blocks, editor, file) => {
  const reader = new FileReader();

  reader.onload = event => insertImageBlock(blocks, editor, file, event.target.result);

  reader.readAsDataURL(file);
};

const insertImageBlock = (blocks, editor, file, src) => {
  editor.insertBlock({
    type,
    nodes: [Block.create({
      type: blocks.image.type,
      data: {
        file,
        src
      }
    })]
  });
};

function Sidebar(_ref) {
  let {
    editor,
    blocks
  } = _ref;
  const icon = jsx("svg", {
    width: 16,
    height: 16,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 576 512"
  }, jsx("path", {
    d: "M480 416v16c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V176c0-26.51 21.49-48 48-48h16v208c0 44.112 35.888 80 80 80h336zm96-80V80c0-26.51-21.49-48-48-48H144c-26.51 0-48 21.49-48 48v256c0 26.51 21.49 48 48 48h384c26.51 0 48-21.49 48-48zM256 128c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-96 144l55.515-55.515c4.686-4.686 12.284-4.686 16.971 0L272 256l135.515-135.515c4.686-4.686 12.284-4.686 16.971 0L512 208v112H160v-48z"
  }));
  return jsx(BlockMenuItem, {
    icon: icon,
    text: "Insert Image",
    insertBlock: () => {
      getFiles().then(files => {
        files.forEach(file => insertImageBlockFromFile(blocks, editor, file));
      });
    }
  });
}

function getImageStyle(alignment) {
  if (alignment === 'left') {
    return {
      float: 'left',
      marginRight: '10px',
      width: '50%'
    };
  } else if (alignment === 'right') {
    return {
      float: 'right',
      marginLeft: '10px',
      width: '50%'
    };
  } else {
    return {
      display: 'block',
      margin: '0px auto',
      width: '100%'
    };
  }
}

function Node(props) {
  let alignment = props.node.data.get('alignment');
  return jsx("figure", _extends({
    css: _objectSpread({
      display: 'flex',
      flexDirection: 'column'
    }, getImageStyle(alignment))
  }, props.attributes), jsx(props.blocks.image.ImageAlignmentContext.Provider, {
    value: useMemo(() => {
      return {
        alignment,

        onAlignmentChange(newAlignment) {
          props.editor.setNodeByKey(props.node.key, {
            data: props.node.data.set('alignment', newAlignment)
          });
        }

      };
    }, [props.node.key, alignment, props.editor, props.node.data])
  }, props.children));
}

let getSchema = _ref2 => {
  let {
    blocks
  } = _ref2;
  return {
    nodes: [{
      match: [{
        type: blocks.image.type
      }],
      min: 1,
      max: 1
    }, {
      match: [{
        type: blocks.caption.type
      }],
      min: 1,
      max: 1
    }],

    normalize(editor, error) {
      switch (error.code) {
        case 'child_min_invalid':
          {
            if (error.index === 0) {
              // the image has been deleted so we also want to delete the image-container
              editor.removeNodeByKey(error.node.key);
            }

            if (error.index === 1) {
              // the caption has been deleted
              // the user probably doesn't want to delete the image
              // they probably just wanted to remove everything in the caption
              // so the caption gets removed,  we insert another caption
              editor.insertNodeByKey(error.node.key, 1, Block.create('caption'));
            }

            return;
          }

        case 'node_data_invalid':
          {
            if (error.key === 'alignment') {
              editor.setNodeByKey(error.node.key, {
                data: error.node.data.set('alignment', 'center')
              });
            }

            return;
          }
      }

      console.log(error);
    },

    data: {
      alignment(value) {
        switch (value) {
          case 'center':
          case 'left':
          case 'right':
            {
              return true;
            }
        }

        return false;
      }

    }
  };
};

let getPlugins = _ref3 => {
  let {
    blocks
  } = _ref3;
  return [insertImages({
    extensions: imageExtensions,
    insertImage: insertImageBlockFromFile.bind(null, blocks)
  }), {
    onDragStart(event, editor, next) {
      const {
        value
      } = editor;
      const {
        document
      } = value;
      const node = findNode(event.target, editor);

      if (node.type === blocks.image.type) {
        const ancestors = document.getAncestors(node.key);
        let imgContainer = ancestors.get(ancestors.size - 1);

        if (imgContainer.type === type) {
          editor.moveToRangeOfNode(imgContainer);
        }
      }

      next();
    }

  }];
};

function serialize(_ref4) {
  let {
    node,
    blocks
  } = _ref4; // Find the 'image' child node

  const imageNode = node.findDescendant(child => child.object === 'block' && child.type === blocks.image.type);

  if (!imageNode) {
    console.error('No image found in a cloudinaryImage block');
    return;
  }

  const joinIds = node.data.get('_joinIds');
  const alignment = node.data.get('alignment');
  const file = imageNode.data.get('file'); // zero out the data field to ensure we don't accidentally store the `file` as
  // a JSON blob

  const newNode = node.setNode(node.getPath(imageNode.key), {
    data: Data.create()
  });
  const mutations = joinIds && joinIds.length ? {
    connect: {
      id: joinIds[0]
    }
  } : {
    create: {
      image: file
    }
  };
  return {
    mutations,
    node: _objectSpread({}, newNode.toJSON(), {
      data: {
        align: alignment
      }
    })
  };
}

function deserialize(_ref5) {
  let {
    node,
    joins,
    blocks
  } = _ref5;

  if (!joins || !joins.length) {
    console.error('No image data received when rehydrating cloudinaryImage block');
    return;
  } // Find the 'image' child node


  const imageNode = node.findDescendant(child => child.object === 'block' && child.type === blocks.image.type);

  if (!imageNode) {
    console.error('No image found in a cloudinaryImage block');
    return;
  }

  return node // Inject the alignment back into the containing block
  .set('data', node.data.set('alignment', joins[0].align)) // And the src attribute into the inner image
  .setNode(node.getPath(imageNode.key), {
    data: imageNode.data.set('src', joins[0].image.publicUrl)
  });
}

export { Node, Sidebar, deserialize, getPlugins, getSchema, path, serialize, type };
