"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), pLazy = _interopDefault(require("p-lazy")), pReflect = _interopDefault(require("p-reflect")), isPromise = _interopDefault(require("p-is-promise")), semver = _interopDefault(require("semver"));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const noop = x => x, identity = noop, getType = thing => Object.prototype.toString.call(thing).replace(/\[object (.*)\]/, "$1"), escapeRegExp = str => (str || "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), mapKeys = (obj, func) => Object.entries(obj).reduce((acc, _ref) => {
  let [key, value] = _ref;
  return _objectSpread({}, acc, {
    [key]: func(value, key, obj)
  });
}, {}), mapKeyNames = (obj, func) => Object.entries(obj).reduce((acc, _ref2) => {
  let [key, value] = _ref2;
  return _objectSpread({}, acc, {
    [func(key, value, obj)]: value
  });
}, {}), resolveAllKeys = obj => {
  const returnValue = {}, errors = {}, allPromises = Object.keys(obj).map(key => pReflect(obj[key]).then(val => (val.isFulfilled ? returnValue[key] = val.value : val.isRejected && (errors[key] = val.reason), 
  val)));
  return Promise.all(allPromises).then(results => {
    if (Object.keys(errors).length) {
      const firstError = results.find(_ref3 => {
        let {isRejected: isRejected} = _ref3;
        return isRejected;
      }).reason, error = new Error(firstError.message || firstError.toString());
      throw error.errors = errors, error;
    }
    return returnValue;
  });
}, unique = arr => [ ...new Set(arr) ], intersection = (array1, array2) => unique(array1.filter(value => array2.includes(value))), pick = (obj, keys) => keys.reduce((acc, key) => key in obj ? _objectSpread({}, acc, {
  [key]: obj[key]
}) : acc, {}), omitBy = (obj, func) => pick(obj, Object.keys(obj).filter(value => !func(value))), omit = (obj, keys) => omitBy(obj, value => keys.includes(value)), objMerge = objs => objs.reduce((acc, obj) => _objectSpread({}, acc, {}, obj), {}), defaultObj = (keys, val) => keys.reduce((acc, key) => _objectSpread({}, acc, {
  [key]: val
}), {}), filterValues = (obj, predicate) => Object.entries(obj).reduce((acc, _ref4) => {
  let [key, value] = _ref4;
  return predicate(value) ? _objectSpread({}, acc, {
    [key]: value
  }) : acc;
}, {}), arrayToObject = function(objs, keyedBy) {
  let mapFn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i => i;
  return objs.reduce((acc, obj) => _objectSpread({}, acc, {
    [obj[keyedBy]]: mapFn(obj)
  }), {});
}, flatten = arr => Array.prototype.concat(...arr), flatMap = function(arr) {
  let fn = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : identity;
  return flatten(arr.map(fn));
}, zipObj = obj => Object.values(obj)[0].map((_, i) => Object.keys(obj).reduce((acc, k) => _objectSpread({}, acc, {
  [k]: obj[k][i]
}), {})), compose = fns => o => fns.reduce((acc, fn) => fn(acc), o), mergeWhereClause = (queryArgs, whereClauseToMergeIn) => {
  if ("Object" !== getType(whereClauseToMergeIn) || 0 === Object.keys(whereClauseToMergeIn).length) return queryArgs;
  return _objectSpread({}, queryArgs, {
    where: queryArgs.where && Object.keys(queryArgs.where).length > 0 ? {
      AND: [ queryArgs.where, whereClauseToMergeIn ]
    } : whereClauseToMergeIn
  });
}, createLazyDeferred = () => {
  let state, resolvedWith, rejectedWith, resolveCallback, rejectCallback;
  return {
    promise: new pLazy((resolve, reject) => {
      "resolved" === state ? resolve(resolvedWith) : "rejected" === state ? reject(rejectedWith) : (resolveCallback = resolve, 
      rejectCallback = reject);
    }),
    resolve: val => {
      resolveCallback ? resolveCallback(val) : (resolvedWith = val, state = "resolved");
    },
    reject: error => {
      rejectCallback ? rejectCallback(error) : (rejectedWith = error, state = "rejected");
    }
  };
}, captureSuspensePromises = executors => {
  const values = [], promises = executors.map(executor => {
    try {
      values.push(executor());
    } catch (loadingPromiseOrError) {
      if (!isPromise(loadingPromiseOrError)) throw loadingPromiseOrError;
      return loadingPromiseOrError;
    }
  }).filter(Boolean);
  if (promises.length) throw Promise.all(promises);
  return values;
}, countArrays = obj => Object.values(obj).reduce((total, items) => total + (items ? items.length : 0), 0), versionGreaterOrEqualTo = (comp, base) => {
  const parseVersion = input => ("object" == typeof input && (input = input.join(".")), 
  semver.coerce(input)), v1 = parseVersion(comp), v2 = parseVersion(base);
  return semver.gte(v1, v2);
};

exports.arrayToObject = arrayToObject, exports.captureSuspensePromises = captureSuspensePromises, 
exports.compose = compose, exports.countArrays = countArrays, exports.createLazyDeferred = createLazyDeferred, 
exports.defaultObj = defaultObj, exports.escapeRegExp = escapeRegExp, exports.filterValues = filterValues, 
exports.flatMap = flatMap, exports.flatten = flatten, exports.getType = getType, 
exports.identity = identity, exports.intersection = intersection, exports.mapKeyNames = mapKeyNames, 
exports.mapKeys = mapKeys, exports.mergeWhereClause = mergeWhereClause, exports.noop = noop, 
exports.objMerge = objMerge, exports.omit = omit, exports.omitBy = omitBy, exports.pick = pick, 
exports.resolveAllKeys = resolveAllKeys, exports.unique = unique, exports.versionGreaterOrEqualTo = versionGreaterOrEqualTo, 
exports.zipObj = zipObj;
