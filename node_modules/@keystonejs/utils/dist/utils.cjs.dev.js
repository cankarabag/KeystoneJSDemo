'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var pLazy = _interopDefault(require('p-lazy'));
var pReflect = _interopDefault(require('p-reflect'));
var isPromise = _interopDefault(require('p-is-promise'));
var semver = _interopDefault(require('semver'));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const noop = x => x;
const identity = noop;
const getType = thing => Object.prototype.toString.call(thing).replace(/\[object (.*)\]/, '$1');
const escapeRegExp = str => (str || '').replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&'); // { key: value, ... } => { key: mapFn(value, key), ... }

const mapKeys = (obj, func) => Object.entries(obj).reduce((acc, _ref) => {
  let [key, value] = _ref;
  return _objectSpread({}, acc, {
    [key]: func(value, key, obj)
  });
}, {}); // { key: value, ... } => { mapFn(key, value): value, ... }

const mapKeyNames = (obj, func) => Object.entries(obj).reduce((acc, _ref2) => {
  let [key, value] = _ref2;
  return _objectSpread({}, acc, {
    [func(key, value, obj)]: value
  });
}, {});
const resolveAllKeys = obj => {
  const returnValue = {};
  const errors = {};
  const allPromises = Object.keys(obj).map(key => pReflect(obj[key]).then(val => {
    if (val.isFulfilled) {
      returnValue[key] = val.value;
    } else if (val.isRejected) {
      errors[key] = val.reason;
    }

    return val;
  }));
  return Promise.all(allPromises).then(results => {
    // If there are any errors, we want to surface them in the same shape as the
    // input object
    if (Object.keys(errors).length) {
      const firstError = results.find((_ref3) => {
        let {
          isRejected
        } = _ref3;
        return isRejected;
      }).reason; // Use the first error as the message so it's at least meaningful

      const error = new Error(firstError.message || firstError.toString());
      error.errors = errors;
      throw error;
    }

    return returnValue;
  });
};
const unique = arr => [...new Set(arr)];
const intersection = (array1, array2) => unique(array1.filter(value => array2.includes(value)));
const pick = (obj, keys) => keys.reduce((acc, key) => key in obj ? _objectSpread({}, acc, {
  [key]: obj[key]
}) : acc, {});
const omitBy = (obj, func) => pick(obj, Object.keys(obj).filter(value => !func(value)));
const omit = (obj, keys) => omitBy(obj, value => keys.includes(value)); // [{ k1: v1, k2: v2, ...}, { k3: v3, k4: v4, ...}, ...] => { k1: v1, k2: v2, k3: v3, k4, v4, ... }
// Gives priority to the objects which appear later in the list

const objMerge = objs => objs.reduce((acc, obj) => _objectSpread({}, acc, {}, obj), {}); // [x, y, z] => { x: val, y: val, z: val}

const defaultObj = (keys, val) => keys.reduce((acc, key) => _objectSpread({}, acc, {
  [key]: val
}), {});
const filterValues = (obj, predicate) => Object.entries(obj).reduce((acc, _ref4) => {
  let [key, value] = _ref4;
  return predicate(value) ? _objectSpread({}, acc, {
    [key]: value
  }) : acc;
}, {}); // [x, y, z] => { x[keyedBy]: mapFn(x), ... }
// [{ name: 'a', animal: 'cat' },
//  { name: 'b', animal: 'dog' },
//  { name: 'c', animal: 'cat' },
//  { name: 'd', animal: 'dog' }]
// arraytoObject(obj, 'name', o => o.animal) =>
// { a: 'cat',
//   b: 'dog',
//   c: 'cat',
//   d: 'dog'}

const arrayToObject = function arrayToObject(objs, keyedBy) {
  let mapFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : i => i;
  return objs.reduce((acc, obj) => _objectSpread({}, acc, {
    [obj[keyedBy]]: mapFn(obj)
  }), {});
}; // [[1, 2, 3], [4, 5], 6, [[7, 8], [9, 10]]] => [1, 2, 3, 4, 5, 6, [7, 8], [9, 10]]

const flatten = arr => Array.prototype.concat(...arr); // flatMap([{ vals: [2, 2] }, { vals: [3] }], x => x.vals) => [2, 2, 3]

const flatMap = function flatMap(arr) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return flatten(arr.map(fn));
}; // { foo: [1, 2, 3], bar: [4, 5, 6]} => [{ foo: 1, bar: 4}, { foo: 2, bar: 5}, { foo: 3, bar: 6 }]

const zipObj = obj => Object.values(obj)[0].map((_, i) => Object.keys(obj).reduce((acc, k) => _objectSpread({}, acc, {
  [k]: obj[k][i]
}), {})); // compose([f, g, h])(o) = h(g(f(o)))

const compose = fns => o => fns.reduce((acc, fn) => fn(acc), o);
const mergeWhereClause = (queryArgs, whereClauseToMergeIn) => {
  if (getType(whereClauseToMergeIn) !== 'Object' || Object.keys(whereClauseToMergeIn).length === 0) {
    return queryArgs;
  }

  const mergedQueryArgs = queryArgs.where && Object.keys(queryArgs.where).length > 0 ? {
    AND: [queryArgs.where, whereClauseToMergeIn]
  } : whereClauseToMergeIn;
  return _objectSpread({}, queryArgs, {
    where: mergedQueryArgs
  });
};
const createLazyDeferred = () => {
  let state;
  let resolvedWith;
  let rejectedWith;
  let resolveCallback;
  let rejectCallback;
  const promise = new pLazy((resolve, reject) => {
    if (state === 'resolved') {
      resolve(resolvedWith);
    } else if (state === 'rejected') {
      reject(rejectedWith);
    } else {
      resolveCallback = resolve;
      rejectCallback = reject;
    }
  });
  return {
    promise,
    resolve: val => {
      if (resolveCallback) {
        resolveCallback(val);
      } else {
        resolvedWith = val;
        state = 'resolved';
      }
    },
    reject: error => {
      if (rejectCallback) {
        rejectCallback(error);
      } else {
        rejectedWith = error;
        state = 'rejected';
      }
    }
  };
};
/**
 * Given an array of functions which may throw a Promise when executed, we want
 * to ensure all functions are executed, reducing any thrown Promises to a
 * single Promise, which is itself rethrown.
 * If no Promises are thrown, this is the equivalent of a .map
 */

const captureSuspensePromises = executors => {
  const values = [];
  const promises = executors.map(executor => {
    try {
      values.push(executor());
    } catch (loadingPromiseOrError) {
      // An actual error was thrown, so we want to bubble that up
      if (!isPromise(loadingPromiseOrError)) {
        throw loadingPromiseOrError;
      } // Return a Suspense promise


      return loadingPromiseOrError;
    }
  }).filter(Boolean);

  if (promises.length) {
    // All the suspense promises are reduced to a single promise then rethrown
    throw Promise.all(promises);
  }

  return values;
}; //ruturns the length of all arrays in obj
// { a: [1, 2], b: [1, 2, 3] } => 5

const countArrays = obj => Object.values(obj).reduce((total, items) => total + (items ? items.length : 0), 0);
/**
 * Compares two version strings or number arrays in the major.minor.patch format.
 * Returns true if comp if each element of comp is greater than than base.
 */

const versionGreaterOrEqualTo = (comp, base) => {
  const parseVersion = input => {
    if (typeof input === 'object') {
      input = input.join('.');
    }

    return semver.coerce(input);
  };

  const v1 = parseVersion(comp);
  const v2 = parseVersion(base);
  return semver.gte(v1, v2);
};

exports.arrayToObject = arrayToObject;
exports.captureSuspensePromises = captureSuspensePromises;
exports.compose = compose;
exports.countArrays = countArrays;
exports.createLazyDeferred = createLazyDeferred;
exports.defaultObj = defaultObj;
exports.escapeRegExp = escapeRegExp;
exports.filterValues = filterValues;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.getType = getType;
exports.identity = identity;
exports.intersection = intersection;
exports.mapKeyNames = mapKeyNames;
exports.mapKeys = mapKeys;
exports.mergeWhereClause = mergeWhereClause;
exports.noop = noop;
exports.objMerge = objMerge;
exports.omit = omit;
exports.omitBy = omitBy;
exports.pick = pick;
exports.resolveAllKeys = resolveAllKeys;
exports.unique = unique;
exports.versionGreaterOrEqualTo = versionGreaterOrEqualTo;
exports.zipObj = zipObj;
