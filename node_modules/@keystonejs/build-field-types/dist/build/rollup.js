"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toUnsafeRollupConfig = toUnsafeRollupConfig;
exports.getRollupConfig = exports.rollup = void 0;

var _path = _interopRequireDefault(require("path"));

var _builtinModules = _interopRequireDefault(require("builtin-modules"));

var _rollup2 = require("rollup");

var _errors = require("../errors");

var _pkgJsonRedirect = _interopRequireDefault(require("../rollup-plugins/pkg-json-redirect"));

var _babel = _interopRequireDefault(require("../rollup-plugins/babel"));

var _utils = require("../utils");

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const resolve = require('rollup-plugin-node-resolve');

const resolveFrom = require('resolve-from');

const chalk = require('chalk');

// this makes sure nested imports of external packages are external
const makeExternalPredicate = externalArr => {
  if (externalArr.length === 0) {
    return () => false;
  }

  const pattern = new RegExp(`^(${externalArr.join('|')})($|/)`);
  return id => pattern.test(id);
};

let unsafeRequire = require;

function getChildPeerDeps(finalPeerDeps, isUMD, depKeys, doneDeps, aliases, pkg) {
  depKeys.filter(x => !doneDeps.includes(x)).forEach(key => {
    let pkgJson;

    try {
      pkgJson = unsafeRequire(resolveFrom(pkg.directory, key + '/package.json'));
    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        return;
      }

      throw err;
    }

    if (pkgJson.peerDependencies) {
      finalPeerDeps.push(...Object.keys(pkgJson.peerDependencies));
      getChildPeerDeps(finalPeerDeps, isUMD, Object.keys(pkgJson.peerDependencies), doneDeps, aliases, pkg);
    }
  });
}

let rollup = _rollup2.rollup;
exports.rollup = rollup;

function toUnsafeRollupConfig(config) {
  return config;
}

let getRollupConfig = (pkg, entrypoints, aliases) => {
  let external = [];

  if (pkg.peerDependencies) {
    external.push(...Object.keys(pkg.peerDependencies));
  }

  if (pkg.dependencies) {
    external.push(...Object.keys(pkg.dependencies));
  }

  getChildPeerDeps(external, false, external, [], aliases, pkg);
  external.push(..._builtinModules.default);
  let rollupAliases = {};
  Object.keys(aliases).forEach(key => {
    try {
      rollupAliases[key] = resolveFrom(pkg.directory, aliases[key]);
    } catch (err) {
      if (err.code !== 'MODULE_NOT_FOUND') {
        throw err;
      }
    }
  });
  let input = {};
  entrypoints.forEach(entrypoint => {
    input[_path.default.relative(pkg.directory, _path.default.join(entrypoint.directory, 'dist', (0, _utils.getNameForDist)(pkg.name)))] = entrypoint.strict().source;
  });
  const config = {
    input,
    external: makeExternalPredicate(external),
    onwarn: warning => {
      switch (warning.code) {
        case 'CIRCULAR_DEPENDENCY':
        case 'UNUSED_EXTERNAL_IMPORT':
          {
            break;
          }

        case 'UNRESOLVED_IMPORT':
          {
            if (/^@babel\/runtime\/helpers\//.test(warning.source)) {
              throw new _errors.FatalError(`Babel helpers (functions inserted by Babel transforms) should be imported from the @babel/runtime package to reduce bundle size but @babel/runtime is not in the dependencies of ${pkg.name}, please add it there.`, pkg);
            }

            if (!warning.source.startsWith('.')) {
              throw new _errors.FatalError(`"${warning.source}" is imported by "${_path.default.relative(pkg.directory, warning.importer)}" but it is not specified in dependencies or peerDependencies`, pkg);
            }

            throw new _errors.FatalError(`"${warning.source}" is imported by "${_path.default.relative(pkg.directory, warning.importer)}" but it could not be resolved`, pkg);
          }

        default:
          {
            throw new _errors.FatalError(`There was an error compiling ${pkg.name}: ${chalk.red(warning.toString())}`, pkg);
          }
      }
    },
    plugins: [(0, _babel.default)({
      cwd: pkg.project.directory,
      plugins: [[require.resolve('../babel-plugins/ks-field-types-in-babel'), {
        pkgDir: pkg.directory
      }], [require.resolve('@babel/plugin-transform-runtime'), {
        useESModules: true
      }]],
      extensions: _constants.EXTENSIONS
    }), resolve({
      extensions: _constants.EXTENSIONS,
      customResolveOptions: {
        moduleDirectory: []
      }
    }), (0, _pkgJsonRedirect.default)()].filter(Boolean)
  };
  return config;
};

exports.getRollupConfig = getRollupConfig;