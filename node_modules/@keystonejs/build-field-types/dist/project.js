"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Project = void 0;

var _sarcastic = _interopRequireDefault(require("sarcastic"));

var _path = _interopRequireDefault(require("path"));

var _prompt = require("./prompt");

var _globby = _interopRequireDefault(require("globby"));

var fs = _interopRequireWildcard(require("fs-extra"));

var _item = require("./item");

var _package = require("./package");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Project extends _item.Item {
  get configPackages() {
    return (0, _sarcastic.default)(this._config.packages, _sarcastic.default.default(_sarcastic.default.arrayOf(_sarcastic.default.string), ['.']));
  } // probably gonna be irrelevant later but i want it for now


  get isBolt() {
    // we only want to return true when there is bolt config
    // AND no yarn workspaces config
    // because emotion has a bolt config and yarn workspaces
    // and if you have both, you probably want workspaces
    let hasBolt = !!this.json.bolt;
    let hasYarnWorkspaces = !!this.json.workspaces;
    return hasBolt && !hasYarnWorkspaces;
  }

  static async create(directory) {
    let filePath = _path.default.join(directory, 'package.json');

    let contents = await fs.readFile(filePath, 'utf-8');
    let project = new Project(filePath, contents);
    project.packages = await project._packages();
    return project;
  }

  get name() {
    return (0, _sarcastic.default)(this.json.name, _sarcastic.default.string);
  }

  set name(name) {
    this.json.name = name;
  }

  async _packages() {
    // suport bolt later probably
    // maybe lerna too though probably not
    if (!this._config.packages && this.json.workspaces) {
      let _workspaces;

      if (Array.isArray(this.json.workspaces)) {
        _workspaces = this.json.workspaces;
      } else if (Array.isArray(this.json.workspaces.packages)) {
        _workspaces = this.json.workspaces.packages;
      }

      let workspaces = (0, _sarcastic.default)(_workspaces, _sarcastic.default.arrayOf(_sarcastic.default.string));
      let packages = await (0, _prompt.promptInput)('what packages should build-field-types build?', this, workspaces.join(','));
      this._config.packages = packages.split(',');
      await this.save();
    }

    let filenames = await (0, _globby.default)(this.configPackages, {
      cwd: this.directory,
      onlyDirectories: true,
      absolute: true,
      expandDirectories: false
    });
    let packages = await Promise.all(filenames.map(async x => {
      let pkg = await _package.Package.create(x);
      pkg.project = this;
      return pkg;
    }));
    return packages;
  }

}

exports.Project = Project;