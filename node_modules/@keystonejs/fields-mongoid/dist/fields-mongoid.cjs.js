'use strict';

var _join = require("path").join;

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty"));

var fields = require('@keystonejs/fields');

var adapterMongoose = require('@keystonejs/adapter-mongoose');

var adapterKnex = require('@keystonejs/adapter-knex');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class MongoIdImplementation extends fields.Implementation {
  gqlOutputFields() {
    return ["".concat(this.path, ": ID")];
  }

  gqlOutputFieldResolvers() {
    return {
      ["".concat(this.path)]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('ID'), ...this.inInputFields('ID')];
  }

  get gqlUpdateInputFields() {
    return ["".concat(this.path, ": ID")];
  }

  get gqlCreateInputFields() {
    return ["".concat(this.path, ": ID")];
  }

}

const validator = a => a ? /^[0-9a-fA-F]{24}$/.test(a.toString()) : true;

const normaliseValue = a => a ? a.toString().toLowerCase() : null;

class MongooseMongoIdInterface extends adapterMongoose.MongooseFieldAdapter {
  addToMongooseSchema(schema, mongoose) {
    // If this field is the primary key we actually don't have to add it; it's implicit
    if (this.field.isPrimaryKey) return;
    const schemaOptions = {
      type: mongoose.Schema.Types.ObjectId,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not a valid Mongo ObjectId'
      }
    };
    schema.add({
      [this.field.isPrimaryKey ? '_id' : this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

  setupHooks(_ref) {
    let {
      addPreSaveHook,
      addPostReadHook
    } = _ref;
    if (!this.field.isPrimaryKey) return;
    addPreSaveHook(item => {
      if (item.id) {
        item._id = item.id;
        delete item.id;
      }

      return item;
    });
    addPostReadHook(itemOrModel => {
      // Sometimes this is called with a mongoose model, sometimes with an object and sometimes with null
      // I do no know why
      const item = itemOrModel && itemOrModel.toObject ? itemOrModel.toObject() : itemOrModel;

      if (item && item._id) {
        item.id = item._id.toString();
        delete item._id;
      }

      return item;
    });
  }

  getQueryConditions(dbPath) {
    const mongoose = this.listAdapter.parentAdapter.mongoose;
    return _objectSpread({}, this.equalityConditions(this.field.isPrimaryKey ? '_id' : dbPath, mongoose.Types.ObjectId), {}, this.inConditions(this.field.isPrimaryKey ? '_id' : dbPath, mongoose.Types.ObjectId));
  }

}

class KnexMongoIdInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.string(this.path, 24);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

  setupHooks(_ref2) {
    let {
      addPreSaveHook,
      addPostReadHook
    } = _ref2;
    addPreSaveHook(item => {
      const valType = typeof item[this.path];

      if (item[this.path] && valType === 'string') {
        item[this.path] = normaliseValue(item[this.path]);
      } else if (!item[this.path] || valType === 'undefined') {
        delete item[this.path];
      } else {
        // Should have been caught by the validator??
        throw "Invalid value given for '".concat(this.path, "'");
      }

      return item;
    });
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = normaliseValue(item[this.path]);
      }

      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread({}, this.equalityConditions(dbPath, normaliseValue), {}, this.inConditions(dbPath, normaliseValue));
  }

}

const MongoId = {
  type: 'MongoId',
  implementation: MongoIdImplementation,
  views: {
    Controller: _join(__dirname, "1kt0g8f"),
    Field: fields.Text.views.Field,
    Filter: _join(__dirname, "688owq")
  },
  adapters: {
    knex: KnexMongoIdInterface,
    mongoose: MongooseMongoIdInterface
  },
  primaryKeyDefaults: {
    knex: {
      getConfig: () => {
        throw "The Uuid field type doesn't provide a default primary key field configuration for knex. " + "You'll need to supply your own 'id' field for each list or use a different field type for your " + "ids (eg '@keystonejs/fields-auto-increment').";
      }
    },
    mongoose: {
      getConfig: () => ({
        type: MongoId
      })
    }
  }
};
exports.MongoId = MongoId;
